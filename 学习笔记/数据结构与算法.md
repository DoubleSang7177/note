## é˜Ÿåˆ— Queue

ä¸€ç§ä»¥é¡ºåºçš„æ–¹å¼ç»´æŠ¤çš„ä¸€ç»„æ•°æ®ï¼Œä¸€ç«¯ï¼ˆå¤´ï¼‰æ·»åŠ æ•°æ®ï¼Œä»å¦ä¸€ç«¯ï¼ˆå°¾ï¼‰ç§»é™¤æ•°æ®ã€‚

## å †

### å¤§æ ¹å †

1.å¤§æ ¹å †æœ‰ç€å¦‚ä¸‹ç‰¹ç‚¹ï¼š
       a.é¡ºåºï¼šå †é¡¶å…ƒç´ æ°¸è¿œæ˜¯æœ€å¤§çš„ã€‚
       b.å½¢çŠ¶ï¼šå †æ˜¯ä¸€é¢—å®Œå…¨äºŒå‰æ ‘ã€‚

 è¿™ä¸¤ä¸ªç‰¹æ€§ä¿è¯äº†å †åœ¨æ’å…¥å’Œåˆ é™¤çš„è¿‡ç¨‹ä¸­æœ€å¤§æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯æ»¡è¶³O(logn)çš„ï¼Œæ‰€ä»¥æ˜¯ä¸€ç§éå¸¸é«˜æ•ˆçš„æ•°æ®ç»“æ„æ ¼å¼ã€‚

2.æ›´æ–°å †çš„ä¸¤ç§æ–¹å¼ï¼Œåˆ†åˆ«å¯¹åº”äº†æ’å…¥å…ƒç´ å’Œåˆ é™¤å †é¡¶å…ƒç´ æ“ä½œï¼š
         è‡ªåº•å‘ä¸Š 
         è‡ªé¡¶å‘ä¸‹

3.å®ç° å¯ä»¥ä½¿ç”¨æ•°ç»„ä½œä¸ºéšå¼æ ‘ï¼ˆå› ä¸ºç»“æ„æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼‰
         å¦‚æœå½“å‰å…ƒç´ çš„ä¸‹æ ‡ä¸ºiï¼Œé‚£ä¹ˆï¼š
        å½“å‰å…ƒç´ çš„çˆ¶äº²ä¸‹æ ‡ï¼ši - 1 / 2 
        å½“å‰å…ƒç´ çš„å·¦å­èŠ‚ç‚¹ä¸‹æ ‡ï¼ši * 2 + 1
        å½“å‰å…ƒç´ çš„å³å­èŠ‚ç‚¹ä¸‹æ ‡ï¼ši * 2 + 2 
        å°æ ¹å †åŒç†

### å°æ ¹å †

## æ ˆ

## æ’åºç®—æ³•

   æ’åºç®—æ³•                 æ—¶é—´å¤æ‚åº¦        ç©ºé—´å¤æ‚åº¦      ç¨³å®šæ€§  

* 1.é€‰æ‹©æ’åº          O(N^2)                O(1)                  X 
* 2.å†’æ³¡æ’åº          O(N^2)                O(1)                 âœ”  
* 3.æ’å…¥æ’åº          O(N^2)                O(1)                 âœ”  
* 4.å½’å¹¶æ’åº          O(N*logN)          O(N)                âœ”  
* 5.å¿«é€Ÿæ’åº3.0     O(N*logN)          O(logN)          X  
* 6.å †æ’åº               O(N*logN)          O(1)                X 

## å›¾

### å›¾ç»“æ„

```java
package graph;

import java.util.HashMap;
import java.util.HashSet;
/*
* å›¾ç»“æ„
* */
public class Graph {
    public HashMap<Integer, Node> nodes;//ç‚¹é›†
    public HashSet<Edge> edges;//è¾¹é›†

    public Graph() {
        this.nodes=new HashMap<>();
        this.edges=new HashSet<>();
    }

    public Graph(HashMap<Integer, Node> nodes, HashSet<Edge> edges) {
        this.nodes = nodes;
        this.edges = edges;
    }

}

```

```java
package graph;

import java.util.ArrayList;

/*
* å›¾èŠ‚ç‚¹
* */
public class Node {
    public int value;
    public int in;//å…¥åº¦ï¼šå…¥èŠ‚ç‚¹ä¸ªæ•°
    public int out;//å‡ºåº¦ï¼šå‡ºèŠ‚ç‚¹ä¸ªæ•°
    public ArrayList<Node> next;
    public ArrayList<Edge> edges;

    public Node() {
        this.next=new ArrayList<>();
        this.edges=new ArrayList<>();
    }

    public Node(int value) {
        this.next=new ArrayList<>();
        this.edges=new ArrayList<>();
        this.value = value;
    }

    public Node(int value, int in, int out, ArrayList<Node> next, ArrayList<Edge> edges) {
        this.value = value;
        this.in = in;
        this.out = out;
        this.next = next;
        this.edges = edges;
    }
}

```

```java
package graph;

/*
* å›¾çš„è¾¹
* */
public class Edge {
    public int weight;//æƒé‡æˆ–è€…é•¿åº¦
    public Node from;
    public Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}

```

### å›¾ç”Ÿæˆå™¨

```java
package graph;
/*
* å›¾ç”Ÿæˆå™¨
* ä¹Ÿå°±æ˜¯æŠŠç”¨æˆ·ç»™å‡ºçš„å›¾ç»“æ„ä»¥è‡ªå·±ç†Ÿæ‚‰çš„å›¾æ–¹å¼è¡¨ç°å‡ºæ¥
* */
public class GraphGenerator {

    /*
    * matrixçŸ©é˜µ
    * N*3
    * ç¬¬ä¸€åˆ—ä»£è¡¨fromèŠ‚ç‚¹çš„å€¼ ç¬¬äºŒåˆ—ä»£è¡¨toèŠ‚ç‚¹çš„å€¼ ç¬¬ä¸‰åˆ—ä»£è¡¨è¾¹çš„æƒé‡
    * */
    public static Graph createGraph(int[][] matrix){
        Graph graph=new Graph();
        for (int i = 0; i < matrix.length; i++) {
            int from = matrix[i][0];
            int to = matrix[i][1];
            int weight = matrix[i][2];
            if (!graph.nodes.containsKey(from)){
                graph.nodes.put(from,new Node(from));
            }
            if (!graph.nodes.containsKey(to)){
                graph.nodes.put(to,new Node(to));
            }
            Node fromNode = graph.nodes.get(from);
            Node toNode = graph.nodes.get(to);
            Edge edge=new Edge(weight,fromNode,toNode);
            fromNode.out++;
            fromNode.next.add(toNode);
            fromNode.edges.add(edge);
            toNode.in++;
            graph.edges.add(edge);
        }
        return graph;
    }
}


```

```java
package graph;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/*
* å›¾çš„å®½åº¦ä¼˜å…ˆéå†
* */
public class BSF {

    /*
    * ä»nodeå‡ºå‘ï¼Œè¿›è¡Œå›¾çš„å®½åº¦ä¼˜å…ˆéå†
    * */
    public static void bsf(Node node){
        if (node==null){
            return;
        }
        Queue<Node> queue=new LinkedList<>();
        //ç”¨setæ˜¯ä¸ºäº†é˜²æ­¢æœ‰ç¯å›¾è¿›å…¥æ­»å¾ªç¯
        HashSet<Node> set=new HashSet<>();
        queue.add(node);
        set.add(node);
        while (!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur.value);
            for (Node next : cur.next) {
                if (!set.contains(next)){
                    set.add(next);
                    queue.add(next);
                }
            }
        }
    }
}

```

### å®½åº¦ä¼˜å…ˆéå†

```java
package graph;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/*
* å›¾çš„å®½åº¦ä¼˜å…ˆéå†
* */
public class BSF {

    /*
    * ä»nodeå‡ºå‘ï¼Œè¿›è¡Œå›¾çš„å®½åº¦ä¼˜å…ˆéå†
    * */
    public static void bsf(Node node){
        if (node==null){
            return;
        }
        Queue<Node> queue=new LinkedList<>();
        //ç”¨setæ˜¯ä¸ºäº†é˜²æ­¢æœ‰ç¯å›¾è¿›å…¥æ­»å¾ªç¯
        HashSet<Node> set=new HashSet<>();
        queue.add(node);
        set.add(node);
        while (!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur.value);
            for (Node next : cur.next) {
                if (!set.contains(next)){
                    set.add(next);
                    queue.add(next);
                }
            }
        }
    }
}

```

### æ‹“æ‰‘æ’åº

```java
package graph;

import java.util.*;

/*
* æ‹“æ‰‘æ’åº
* */
public class SortedTopology {

    //æœ‰å‘æ— ç¯å›¾
    public static ArrayList<Node> sortedTopology(Graph graph){
        if (graph ==null){
            return null;
        }
        //æ”¶é›†å…¥åº¦ä¸º0çš„èŠ‚ç‚¹
        Queue<Node> queue=new LinkedList<>();
        //è®°å½•æ‰€æœ‰èŠ‚ç‚¹çš„å…¥åº¦
        HashMap<Node,Integer> map=new HashMap<>();
        //ä¿å­˜ç»“æœå¹¶è¿”å›
        ArrayList<Node> list=new ArrayList<>();
        for (Node node : graph.nodes.values()) {
            if (node.in==0){
                queue.add(node);
            }
            map.put(node,node.in);
        }
        while (!queue.isEmpty()){
            Node cur = queue.poll();
            list.add(cur);
            for (Node next:cur.next){
                map.put(next,map.get(next)-1);
                if (map.get(next)==0){
                    queue.add(next);
                }
            }
        }
        return list;
    }

    public static void main(String[] args) {
        Graph graph = new Graph();
        Node A=new Node(1);
        A.in=0;
        A.out=2;
        Node B=new Node(2);
        B.in=1;
        B.out=2;
        Node C=new Node(3);
        C.in=2;
        C.out=1;
        A.next.add(B);
        A.next.add(C);
        B.next.add(C);
        Node D=new Node(4);
        D.in=2;
        D.out=0;
        B.next.add(D);
        C.next.add(D);
        Edge e1 = new Edge(1, A, C);
        Edge e2 = new Edge(1, A, B);
        Edge e3 = new Edge(1, B, D);
        Edge e4 = new Edge(1, B, C);
        Edge e5 = new Edge(1, C, D);
        A.edges.add(e1);
        A.edges.add(e2);
        B.edges.add(e3);
        B.edges.add(e4);
        C.edges.add(e5);
        graph.nodes.put(1,A);
        graph.nodes.put(2,B);
        graph.nodes.put(3,C);
        graph.nodes.put(4,D);
        graph.edges.add(e1);
        graph.edges.add(e2);
        graph.edges.add(e3);
        graph.edges.add(e4);
        graph.edges.add(e5);
        for (Node x : sortedTopology(graph)) {
            System.out.print(x.value+" ");
        }
        System.out.println();
    }
}

```

### æœ€å°ç”Ÿæˆæ ‘

```java
package graph;

import java.util.*;

/*
 * æ‰¾å‡ºå›¾ä¸­çš„æœ€å°ç”Ÿæˆæ ‘
 * æœ€å°ç”Ÿæˆæ ‘ MinimumSpanningTree
 * */
public class MST {
    public static HashMap<Node, List<Node>> listMap = new HashMap<>();

    //ç”Ÿæˆæ¯ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„é›†åˆè¡¨
    public static void getSetMap(Graph graph) {
        if (graph == null) {
            return;
        }
        for (Node cur : graph.nodes.values()) {
            List<Node> set = new ArrayList<>();
            set.add(cur);
            listMap.put(cur, set);
        }
    }

    //åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„é›†åˆæ˜¯å¦ç›¸åŒ
    public static boolean isSameSet(Node from, Node to) {
        List<Node> fromList = listMap.get(from);
        List<Node> toList = listMap.get(to);
        return fromList == toList;
    }

    //åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹çš„é›†åˆ
    public static void union(Node from, Node to) {
        List<Node> fromList = listMap.get(from);
        List<Node> toList = listMap.get(to);
        for (Node node : fromList) {
            toList.add(node);
            listMap.put(node, toList);
        }
    }

    //å®šä¹‰ä¸€ä¸ªè¾¹æ¯”è¾ƒå™¨
    public static class EdgeComparator implements Comparator<Edge> {
        @Override
        public int compare(Edge o1, Edge o2) {
            return o1.weight - o2.weight;
        }
    }

    /*
     * kç®—æ³•å¯»æ‰¾æœ€å°ç”Ÿæˆæ ‘
     * */
    public static Set<Edge> kruskalMST(Graph graph) {
        Set<Edge> result = new HashSet<>();
        getSetMap(graph);
        PriorityQueue<Edge> queue = new PriorityQueue<>(new EdgeComparator());
        queue.addAll(graph.edges);
        while (!queue.isEmpty()) {
            Edge cur = queue.poll();
            if (!isSameSet(cur.from, cur.to)) {
                result.add(cur);
                union(cur.from, cur.to);
            }
        }
        return result;
    }
    /*
     * pç®—æ³•å¯»æ‰¾æœ€å°ç”Ÿæˆæ ‘
     * */
    public static Set<Edge> primMST(Graph graph) {
        Set<Edge> result = new HashSet<>();
        //æ ‡è®°è¿‡çš„è¾¹æ”¾å…¥é˜Ÿåˆ—æŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—
        PriorityQueue<Edge> queue = new PriorityQueue<>(new EdgeComparator());
        //åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦è¢«è€ƒå¯Ÿè¿‡,è€ƒå¯Ÿè¿‡çš„æ”¾å…¥é›†åˆä¸­
        Set<Node> isCheck = new HashSet<>();
        for (Node node : graph.nodes.values()) {//ä¸ºäº†å¤„ç†æ•´ä¸ªå›¾ä¸è¿é€šçš„é—®é¢˜ï¼Œæ£®æ—
            //ä»ä¸€ä¸ªæ²¡æœ‰è¢«è€ƒå¯Ÿè¿‡çš„èŠ‚ç‚¹å¼€å§‹
            if (!isCheck.contains(node)){
                //æŠŠå½“å‰èŠ‚ç‚¹æ ‡è®°ä¸ºå·²è€ƒå¯Ÿ
                isCheck.add(node);
                //æŠŠè¯¥èŠ‚ç‚¹çš„æ‰€æœ‰è¾¹æ”¾å…¥æ ‡è®°é˜Ÿåˆ—
                queue.addAll(node.edges);
                while (!queue.isEmpty()){
                    Edge poll = queue.poll();
                    if (!isCheck.contains(poll.to)){
                        result.add(poll);
                        isCheck.add(poll.to);
                        queue.addAll(poll.to.edges);
                    }
                }
            }
        }
        return result;
    }

    /*
     * æˆ‘è‡ªå·±å†™çš„pç®—æ³•ä»£ç ï¼Œæœ‰å¾…è€ƒéªŒ
     * */
    public static Set<Edge> primMST2(Graph graph) {
        Set<Edge> result = new HashSet<>();
        //æ ‡è®°è¿‡çš„è¾¹æ”¾å…¥é˜Ÿåˆ—æŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åˆ—
        PriorityQueue<Edge> queue = new PriorityQueue<>(new EdgeComparator());
        //åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦è¢«è€ƒå¯Ÿè¿‡,è€ƒå¯Ÿè¿‡çš„æ”¾å…¥é›†åˆä¸­
        Set<Node> isCheck = new HashSet<>();
        //åˆ¤æ–­è¾¹æ˜¯å¦å·²ç»æ ‡è®°è¿‡
        HashMap<Edge, Boolean> isMark = new HashMap<>();
        //ä¸€å¼€å§‹æ‰€æœ‰çš„è¾¹éƒ½æ˜¯æ²¡æœ‰æ ‡è®°è¿‡çš„
        for (Edge edge : graph.edges) {
            isMark.put(edge, false);
        }
        Stack<Node> stack=new Stack<>();
        for (Node value : graph.nodes.values()) {
            stack.push(value);//é€‰æ‹©ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ï¼Œï¼Œæ€ä¹ˆé€‰å‘¢ï¼Ÿ
            //é€‰æ‹©å›¾ä¸­çš„ä»»æ„èŠ‚ç‚¹å¼€å§‹å¯»æ‰¾æœ€å°ç”Ÿæˆæ ‘
            while (!stack.isEmpty()) {
                ArrayList<Edge> edges = stack.pop().edges;
                //æ ‡è®°æ‰€æœ‰æ²¡æœ‰æ ‡è®°è¿‡çš„è¾¹æ”¾å…¥é˜Ÿåˆ—
                for (Edge edge : edges) {
                    if (!isMark.get(edge)){
                        isMark.put(edge,true);
                        queue.add(edge);
                    }
                }
                //å–å‡ºæ ‡è®°è¿‡çš„è¾¹ä¸­çš„æœ€å°
                Edge poll = queue.poll();
                while (!queue.isEmpty()){
                    if (!isCheck.contains(poll.to) ||!isCheck.contains(poll.from)){
                        result.add(poll);
                        isCheck.add(poll.to);
                        isCheck.add(poll.from);
                        stack.push(!isCheck.contains(poll.to)?poll.to:poll.from);
                    }else{
                        poll=queue.poll();
                    }
                }
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Graph graph = new Graph();
        Node A=new Node(1);
        A.in=0;
        A.out=2;
        Node B=new Node(2);
        B.in=1;
        B.out=2;
        Node C=new Node(3);
        C.in=2;
        C.out=1;
        A.next.add(B);
        A.next.add(C);
        B.next.add(C);
        Node D=new Node(4);
        D.in=2;
        D.out=0;
        B.next.add(D);
        C.next.add(D);
        Edge e1 = new Edge(1, A, C);
        Edge e2 = new Edge(1, A, B);
        Edge e3 = new Edge(1, B, D);
        Edge e4 = new Edge(1, B, C);
        Edge e5 = new Edge(1, C, D);
        A.edges.add(e1);
        A.edges.add(e2);
        B.edges.add(e3);
        B.edges.add(e4);
        C.edges.add(e5);
        graph.nodes.put(1,A);
        graph.nodes.put(2,B);
        graph.nodes.put(3,C);
        graph.nodes.put(4,D);
        graph.edges.add(e1);
        graph.edges.add(e2);
        graph.edges.add(e3);
        graph.edges.add(e4);
        graph.edges.add(e5);
        Set<Edge> edges = primMST2(graph);
        for (Edge edge : edges) {
            System.out.println(edge.weight);
        }
        System.out.println("=======");
        Set<Edge> edges2 = primMST(graph);
        for (Edge edge : edges2) {
            System.out.println(edge.weight);
        }
    }

}

```

### è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•

è§£æ³• ä¸€

```java
package graph;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
/*
* è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•
* ç”¨ä¸€ä¸ªHashMapè®°å½•åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„è·ç¦»
* ç”¨ä¸€ä¸ªHashSeté›†åˆè®°å½•é”å®š(ä¸åœ¨æ›´æ–°åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»ï¼Œå·²ç»æ‰¾åˆ° åˆ°è¯¥èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»)çš„èŠ‚ç‚¹
* */
public class Dijkstral {
    public static HashMap<Node,Integer> dijkstral(Node head){
        //è®°å½•ä»æŒ‡å®šèŠ‚ç‚¹åˆ°æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
        HashMap<Node,Integer> distanceMap=new HashMap<>();
        //å¦‚æœæ‰¾åˆ°åˆ°æŸèŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œé‚£ä¹ˆé”ä½è¯¥èŠ‚ç‚¹å’Œå¯¹åº”è·ç¦»
        Set<Node> selected=new HashSet<>();
        //å¼€å§‹èŠ‚ç‚¹åˆ°è‡ªå·±çš„è·ç¦»ä¸ºé›¶ï¼Œå¹¶ä¸”ç›®å‰æ²¡æœ‰è¢«é”å®š
        distanceMap.put(head,0);
        //é¦–å…ˆæ‰¾åˆ°åˆ°æŒ‡å®šèŠ‚ç‚¹è·ç¦»æœ€çŸ­çš„å¹¶ä¸”æ²¡æœ‰è¢«é”å®šçš„èŠ‚ç‚¹
        Node minNode=getMinDistanceAndUnSelectedNode(distanceMap,selected);//è¿™é‡Œå¾—åˆ°çš„minNodeå°±æ˜¯æŒ‡å®šèŠ‚ç‚¹è‡ªå·±
        while (minNode!=null){
            int minNodeDistance= distanceMap.get(minNode);
            for (Edge edge : minNode.edges) {
                Node toNode=minNode!=edge.to?edge.to:minNode;//æ— å‘å›¾ï¼Œèƒ½ç¡®ä¿edge.toæ˜¯è¿™ä¸ªè¾¹ä¸Šçš„å¦ä¸€ç«¯çš„èŠ‚ç‚¹å—ï¼Ÿæœ‰ç‚¹ç–‘é—®
//                TrieNode toNode=minNode!=edge.to; //ä¸ºäº†å®‰å…¨èµ·è§è¿˜æ˜¯åˆ¤æ–­ä»¥ä¸‹
                if (!distanceMap.containsKey(toNode)){
                    distanceMap.put(toNode,minNodeDistance+edge.weight);
                }else {
                    distanceMap.put(toNode,Math.min(distanceMap.get(toNode),minNodeDistance+edge.weight));
                }
            }
            selected.add(minNode);
            minNode=getMinDistanceAndUnSelectedNode(distanceMap,selected);
        }
        return distanceMap;
    }

    private static Node getMinDistanceAndUnSelectedNode(HashMap<Node, Integer> distanceMap, Set<Node> selected) {
        int minDistance=Integer.MAX_VALUE;
        Node minNode=null;
        for (Node node : distanceMap.keySet()) {
            if (distanceMap.get(node)<minDistance && !selected.contains(node)){
                minNode=node;
                minDistance=distanceMap.get(node);
            }
        }
        return minNode;
    }
}

```

è§£æ³•äºŒ

```java
package heap;
import graph.Edge;
import graph.Node;
import java.util.HashMap;
/*
* ç”¨è‡ªå®šä¹‰çš„å°æ ¹å †å®ç°è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•
* å‘å°æ ¹å †ä¸­åŠ å…¥æŸèŠ‚ç‚¹å’Œåˆ°è¯¥èŠ‚ç‚¹çš„æ–°è·ç¦»ä¹‹å
* å°æ ¹å †ä¼šæ ¹æ®ä¼ å…¥çš„æ–°è·ç¦»åˆ¤æ–­æ˜¯å¦è¦æ›´æ–°è·ç¦»ï¼Œ
* å¹¶ä¸”åŠ å…¥ä¸€ä¸ªæ–°èŠ‚ç‚¹ä¼šè‡ªåŠ¨è¿›è¡Œçƒ­æ’åºï¼Œä¸€ç›´ä¿æŒå°æ ¹å †ï¼Œ
* popçš„èŠ‚ç‚¹éƒ½æ˜¯è·ç¦»æœ€å°çš„èŠ‚ç‚¹ï¼ŒåŠ å…¥ç»“æœé›†ä¸­è¿”å›
*
* */
public class Dijkstral {
    public static HashMap<Node,Integer> dijkstral(Node head,int size){
        HashMap<Node,Integer> resultMap=new HashMap<>();
        NodeHeap nodeHeap = new NodeHeap(size);
        nodeHeap.addOrUpdateOrIgnore(head,0);
        while (!nodeHeap.isEmpty()) {
            NodeHeap.NodeRecord pop = nodeHeap.pop();
            Node cur= pop.node;
            int distance= pop.distance;
            for (Edge edge : cur.edges) {
                //å°†åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»distanceåŠ ä¸Šé‚»è¾¹çš„æƒé‡weightä½œä¸ºåˆ°toèŠ‚ç‚¹çš„æ–°è·ç¦»ä¼ å…¥å°æ ¹å †ï¼Œå°æ ¹å †ä¼šåˆ¤æ–­æ˜¯å¦è¦æ›´æ–°æˆä¼ å…¥çš„è·ç¦»ï¼Œä¼šåšåˆ¤æ–­
                nodeHeap.addOrUpdateOrIgnore(edge.to,distance+ edge.weight);
            }
            resultMap.put(cur,distance);
        }
        return resultMap;
    }
    public static class NodeHeap{
        /*
         * distanceæ“ä½œ
         * 1. åœ¨å †ä¸Šçš„ï¼Œupdate
         * 2. æ²¡è¿›è¿‡å †çš„ï¼Œnew
         * 3. è¿›è¿‡å †ä½†æ˜¯ä¸åœ¨å †ä¸Šçš„ï¼Œignore
         * */
        public void addOrUpdateOrIgnore(Node node,int distance){
            //ç¬¬ä¸€ç§æƒ…å†µï¼šå·²ç»åœ¨å †ä¸Š
            if (inHeap(node)){
                distanceMap.put(node,Math.min(distanceMap.get(node),distance));
                //å†’æ³¡
                insertHeapify(node,heapIndexMap.get(node));
            }
            //ç¬¬äºŒç§æƒ…å†µï¼šæ–°è¿›çš„èŠ‚ç‚¹ï¼Œæ”¾åœ¨æœ€åä¸€ä¸ªä½ç½®
            if (!isEntered(node)){
                nodes[size]=node;
                heapIndexMap.put(node,size);
                distanceMap.put(node,distance);
                //æ–°åŠ å…¥ï¼Œå†’æ³¡
                insertHeapify(node,size++);
            }
            //ç¬¬ä¸‰ç§æƒ…å†µï¼šå·²ç»è¢«è€ƒå¯Ÿå®Œçš„èŠ‚ç‚¹ï¼Œä¸åšå¤„ç†

        }
        public NodeRecord pop(){
            //å¼¹å‡ºæ ¹èŠ‚ç‚¹
            NodeRecord nodeRecord=new NodeRecord(nodes[0],distanceMap.get(nodes[0]));
            //å°†åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»æ ‡ä¸º-1
            swap(0,size-1);
            //å°†è¦å¼¹å‡ºçš„èŠ‚ç‚¹çš„ä¸‹æ ‡è¡¨ç¤ºæˆ-1
            heapIndexMap.put(nodes[size-1],-1);
            //ä»è·ç¦»mapä¸­åˆ é™¤è¯¥èŠ‚ç‚¹ä¿¡æ¯
            distanceMap.remove(nodes[size-1]);
            nodes[size-1]=null;
            //ä»æ–°çš„æ ¹èŠ‚ç‚¹å¼€å§‹å¾€ä¸‹ç§»åŠ¨ä¸€è½®
            heapify(0,--size);
            return nodeRecord;
        }
        //å †ä¸ŠèŠ‚ç‚¹
        private Node[] nodes;
        //keyä¸ºå †ä¸ŠèŠ‚ç‚¹ï¼Œvalueä¸ºè¯¥èŠ‚ç‚¹åœ¨å †ä¸Šçš„ä½ç½®
        private HashMap<Node,Integer> heapIndexMap;
        //keyä¸ºå †ä¸ŠèŠ‚ç‚¹ï¼Œvalueä¸ºAèŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·ç¦»
        private HashMap<Node,Integer> distanceMap;
        //å †ä¸ŠèŠ‚ç‚¹ä¸ªæ•°
        private int size;
        public NodeHeap(int size) {
            this.nodes = new Node[size];
            this.heapIndexMap = new HashMap<>();
            this.distanceMap = new HashMap<>();
            this.size=0;
        }
        public boolean isEmpty(){
            return size==0;
        }

        //æ ‡å¿—ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿›è¿‡å †
        private boolean isEntered(Node node){
            return heapIndexMap.containsKey(node);
        }
        //åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ä¸æ˜¯åœ¨å †ä¸Š
        private boolean inHeap(Node node){
            return isEntered(node) && heapIndexMap.get(node)!=-1;
        }
        //äº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹
        private void swap(int index1,int index2){
            heapIndexMap.put(nodes[index1],index2);
            heapIndexMap.put(nodes[index2],index1);
            Node temp=nodes[index1];
            nodes[index1]=nodes[index2];
            nodes[index2]=temp;
        }


        public static class NodeRecord{
            private Node node;
            private int distance;

            public NodeRecord(Node node, int distance) {
                this.node = node;
                this.distance = distance;
            }
        }

        //å‘ä¸‹ç§»åŠ¨
        private void heapify(int index, int size) {
            int left=index*2+1;
            while (left<size){
                int min=left+1<size&&distanceMap.get(nodes[left])<distanceMap.get(nodes[left+1])?left:left+1;
                min=distanceMap.get(nodes[min])<distanceMap.get(nodes[index])?min:index;
                if (min==index){
                    return;
                }
                swap(min,index);
                index=min;
                left=index*2+1;
            }
        }
        //è·ç¦»å°çš„èŠ‚ç‚¹å¾€ä¸Šçªœ
        private void insertHeapify(Node node, Integer index) {
            while (distanceMap.get(nodes[index])<distanceMap.get(nodes[(index-1)/2])){
                swap(index,(index-1)/2);
                index=(index-1)/2;
            }
        }
    }
}

```

### å‰ç¼€æ ‘

```java
package tree;

/*
 * å‰ç¼€æ ‘
 * */
public class TrieTree {
    /*
     * å‰ç¼€æ ‘æ ¹èŠ‚ç‚¹
     * */
    private TrieNode root;

    /*
     * å‰ç¼€æ ‘èŠ‚ç‚¹
     * */
    public class TrieNode {
        int pass;
        int end;
        TrieNode[] next;

        public TrieNode() {
            this.pass = 0;
            this.end = 0;
            /*
             * æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥èµ°å‘26æ¡è·¯
             * next[0]!=null è¯´æ˜è¯¥èŠ‚ç‚¹æœ‰èµ°å‘'a'çš„è·¯
             * next[1]!=null è¯´æ˜è¯¥èŠ‚ç‚¹æœ‰èµ°å‘'b'çš„è·¯
             * ....
             * next[2]!=null è¯´æ˜è¯¥èŠ‚ç‚¹æœ‰èµ°å‘'c'çš„è·¯
             * */
            this.next = new TrieNode[26];
        }
    }

    public TrieTree() {
        this.root = new TrieNode();
    }

    /*
     * æ·»åŠ å­—ç¬¦ä¸²
     * */
    public void insert(String word) {
        if (word == null) {
            return;
        }
        char[] chars = word.toCharArray();
        TrieNode cur = root;
        root.pass++;
        int index = 0;
        for (int i = 0; i < chars.length; i++) {
            index = chars[i] - 'a';
            if (cur.next[index] == null) {
                cur.next[index] = new TrieNode();
            }
            cur = cur.next[index];
            cur.pass++;
        }
        cur.end++;
    }

    /*
     * åˆ é™¤å­—ç¬¦ä¸²ï¼Œåˆ ä¸€æ¬¡å°±è¡Œã€‚ã€‚
     * */
    public boolean delete(String word) {
        if (word == null || search(word)==0) {
            return false;
        }
        char[] chars = word.toCharArray();
        TrieNode cur = root;
        root.pass--;
        int index=0;//å…¶å®å¯ä»¥ä¸èµ‹å€¼çš„
        for (char c : chars) {
            index = c - 'a';
            if (cur.next[index] != null && --cur.next[index].pass == 0) {
                cur.next[index] = null;
                return true;
            }
            //ä¸Šé¢çš„åˆ¤æ–­å°±ç®—ä¸æˆç«‹passå€¼ä¹Ÿå·²ç»å‡äº†
            cur = cur.next[index];
        }
        cur.end--;
        return true;
    }

    /*
     * æŸ¥çœ‹å­—ç¬¦ä¸²ä¹‹å‰åŠ å…¥è¿‡å‡ æ¬¡
     * */
    public int search(String word) {
        if (word == null) {
            return 0;
        }
        char[] chars = word.toCharArray();
        TrieNode cur = root;
        int index = 0;
        for (char aChar : chars) {
            index = aChar - 'a';
            if (cur.next[index] == null) {
                return 0;
            }
            cur = cur.next[index];
        }
        return cur.end;
    }

    /*
     * æ‰€æœ‰åŠ å…¥çš„å­—ç¬¦ä¸²ä¸­ï¼Œæœ‰å‡ ä¸ªå­—ç¬¦ä¸²æ˜¯ä»¥preä¸ºå‰ç¼€çš„
     * */
    public int prefixNumber(String pre) {
        if (pre == null) {
            return 0;
        }
        char[] chars = pre.toCharArray();
        TrieNode cur = root;
        int index = 0;
        for (char aChar : chars) {
            index = aChar - 'a';
            if (cur.next[index] == null) {
                return 0;
            }
            cur = cur.next[index];
        }
        return cur.pass;
    }
}

```

### è´ªå¿ƒç®—æ³•

åœ¨æŸä¸€ä¸ªæ ‡å‡†ä¸‹ï¼Œä¼˜å…ˆè€ƒè™‘æœ€æ»¡è¶³æ ‡å‡†çš„æ ·æœ¬ï¼Œæœ€åè€ƒè™‘æœ€ä¸æ»¡è¶³æ ‡å‡†çš„çš„æ ·æœ¬ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªç­”æ¡ˆçš„ç®—æ³•ï¼Œå«åšè´ªå¿ƒç®—æ³•ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ä»æ•´ä½“æœ€ä¼˜ä¸ŠåŠ ä»¥è€ƒè™‘ï¼Œæ‰€åšå‡ºçš„æ˜¯åœ¨æŸç§æ„ä¹‰ä¸Šçš„å±€éƒ¨æœ€ä¼˜è§£ã€‚

#### å®‰æ’æœ€å¤šçš„ä¼šè®®

```java

package greedyAlgprithm;
import java.util.Arrays;
import java.util.Comparator;

/*
* è´ªå¿ƒç®—æ³•
* */
public class BestArrange {
    /*
    * ä¼šè®®
    * æœ‰å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´
    * */
    public class Program{
        int start;
        int end;
    }
    /*
    * ä¼šè®®æ¯”è¾ƒå™¨
    * æŒ‰ç»“æŸæ—¶é—´ä»å°åˆ°å¤§æ’åº
    * */
    public class ProgramComparator implements Comparator<Program>{
        @Override
        public int compare(Program o1, Program o2) {
            return o1.end-o2.end;
        }
    }

    /*
    * ä»€ä¹ˆé¡ºåºå®‰æ’ä¼šè®®æ‰èƒ½ä½¿è¢«å®‰æ’çš„ä¼šè®®æ•°é‡æœ€å¤§
    * */
    public int bestArrange(Program[] programs, int timePoint) {
        int count = 0;
        //æ•°ç»„æ’åºä¼ æ¯”è¾ƒå™¨ç›´æ¥è°ƒArrays.sort()å°±è¡Œ
        Arrays.sort(programs,new ProgramComparator());
         for (Program cur:programs) {
            if (cur.start >= timePoint) {
                count++;
                timePoint = cur.end;
            }
        }
        return count;
    }

}

```

#### åˆ©æ¶¦æœ€å¤§åŒ–

```java
package greedyAlgprithm;
import java.util.Comparator;
import java.util.PriorityQueue;
/*
* è´ªå¿ƒç®—æ³•
* åœ¨è§„å®šèƒ½åšçš„é¡¹ç›®æœ€å¤§ä¸ªæ•°çš„æƒ…å†µä¸‹åšå‡ºåˆ©æ¶¦æœ€å¤§åŒ–
* */
public class IPO {
    public static class Node{
        int capital;
        int profit;

        public Node(int capital, int profit) {
            this.capital = capital;
            this.profit = profit;
        }
    }

    public static class MinCostComparator implements Comparator<Node>{

        @Override
        public int compare(Node o1, Node o2) {
            return o1.capital -o2.capital;
        }
    }
    public static class MaxProfitComparator implements Comparator<Node>{

        @Override
        public int compare(Node o1, Node o2) {
            return o2.profit-o1.profit;
        }
    }

    public static int ipo(int[] profits,int[] capital,int w,int k){
        //wä¸ºåˆå§‹èµ„é‡‘ kä¸ºæœ€å¤šèƒ½åšçš„é¡¹ç›®ä¸ªæ•°
        PriorityQueue<Node> minCostQ=new PriorityQueue<>(new MinCostComparator());
        PriorityQueue<Node> maxProfitQ=new PriorityQueue<>(new MaxProfitComparator());
        for (int i = 0; i < profits.length; i++) {
            minCostQ.add(new Node(capital[i],profits[i]));
        }
        for (int i = 0; i < k; i++) {
            //è§£é”æ‰€æœ‰å¯åŠ¨èµ„é‡‘å°äºå½“å‰æ‰€æ‹¥æœ‰çš„èµ„é‡‘çš„é¡¹ç›®
            while (!minCostQ.isEmpty() && minCostQ.peek().capital<=w){
                maxProfitQ.add(minCostQ.poll());
            }
            //æ²¡æœ‰èƒ½åšçš„é¡¹ç›®ï¼Œç›´æ¥è¿”å›
            if (maxProfitQ.isEmpty()){
                break;
            }
            //åœ¨èƒ½åšçš„é¡¹ç›®ä¸­é€‰å‡ºåˆ©æ¶¦æœ€å¤§çš„é¡¹ç›®æ¥åšï¼Œåšå®Œæ›´æ–°å½“å‰èµ„é‡‘
            w +=maxProfitQ.poll().profit;
        }
        return w;
    }
}

```

#### åˆ‡åˆ†é‡‘æ¡

```java
package greedyAlgprithm;
import java.util.PriorityQueue;

/*
* è´ªå¿ƒç®—æ³•
* ç”¨æœ€å°‘çš„é“œæ¿åˆ‡åˆ†é‡‘æ¡
* */
public class LessMoneySplitGold {
    public static int lessMoneySplitGold(int[] arr){
        int sum=0;
        //å°æ ¹å †
        PriorityQueue<Integer> queue=new PriorityQueue<>();
        for (int i : arr) {
            queue.add(i);
        }
        int cur;
        while (queue.size()>1){
            cur=queue.poll()+queue.poll();
            sum+=cur;
            queue.add(cur);
        }
        return sum;
    }

}

```

#### æœ€å°å­—å…¸åº

```java
package greedyAlgprithm;

import java.util.Arrays;
import java.util.Comparator;

/*
* è´ªå¿ƒç®—æ³•
* æŒ‰ç…§æœ€å°å­—å…¸åºè¿›è¡Œæ’åº
* */
public class LowestLexicography {
    public static class StringComparator implements Comparator<String>{

        @Override
        public int compare(String o1, String o2) {
            return (o1+o2).compareTo(o2+o1);
        }
    }
    public static String lowestLexicography(String[] strings){
        if (strings==null || strings.length==0){
            return "";
        }
        StringBuilder result= new StringBuilder();
        Arrays.sort(strings, new StringComparator());
        for (String string : strings) {
            result.append(string);
        }
        return result.toString();
    }
}

```

#### Nçš‡åé—®é¢˜

```java
package greedyAlgprithm;
/*
* è´ªå¿ƒç®—æ³•
* Nçš‡åé—®é¢˜
* è¿˜æœ‰ä¸€ä¸ªä½è¿ç®—èƒ½å¤Ÿæ”¹å–„å¸¸ç†Ÿçº§åˆ«çš„ä½†æ˜¯æ²¡å¬æ‡‚ã€‚ã€‚ã€‚
* */
public class Num {
    /*
    * ç»å…¸è§£æ³•
    * */
    public static int num(int n){
        if (n<1){
            return 0;
        }
        int[] record=new int[n];
        return process(n,0,record);
    }

    /*
    * æ½œå°è¯ï¼šrecord[0...i-1]ä¸Šçš„ä»»ä½•ä¸¤ä¸ªçš‡åéƒ½ä¸å…±è¡Œï¼Œä¸å…±åˆ—ï¼Œä¹Ÿä¸å…±æ–œçº¿
    * ç›®å‰æ¥åˆ°äº†ç¬¬iè¡Œ
    * record[0..i-1]è¡¨ç¤º0åˆ°i-1è¡Œæ”¾äº†çš‡åçš„ä½ç½®
    * nä»£è¡¨æ•´ä½“æœ‰å¤šå°‘è¡Œ
    * è¿”å›å€¼æ˜¯æ‘†å®Œæ‰€æœ‰çš„çš‡åï¼Œåˆç†çš„æ‘†æ³•æœ‰å¤šå°‘ç§
    * */
    private static int process(int n, int i, int[] record) {
        if (n==i){//ç»ˆæ­¢è¡Œ
            return 1;
        }
        int sum=0;
        for (int j = 0; j < n; j++) {//å½“å‰åœ¨iè¡Œï¼Œå°è¯•iè¡Œæ‰€æœ‰çš„åˆ—
            if (isValid(record,i,j)){//åˆ¤æ–­èƒ½ä¸èƒ½æ”¾ï¼ˆi,j)ä½ç½®
                record[i]=j;//æ»¡è¶³æ¡ä»¶ï¼Œæ”¾çš‡å
                sum+=process(n,i+1,record);//æ”¾è¯¥ä½ç½®åï¼Œä¸‹é¢çš„è¡Œæœ‰å¤šå°‘ç§åˆç†æ‘†æ³•ï¼Œè¿›è¡Œç»Ÿè®¡
            }
        }
        return sum;//è¿”å›æ‰€æœ‰åˆç†æ‘†æ³•çš„ç»Ÿè®¡ç»“æœ
    }

    /*
    * æŸ¥çœ‹å¦‚æœæŠŠçš‡åæ”¾åœ¨(i,j)çš„ä½ç½®
    * æ˜¯å¦å’Œrecord[0....i-1]ä¸Šå·²ç»æ‘†æ”¾å¥½çš„çš‡åå†²çª
    * åªè¦åˆ¤æ–­ä¸å…±è¡Œå’Œä¸å…±æ–œçº¿å°±è¡Œï¼Œå› ä¸ºä¸åœ¨åŒä¸€è¡Œï¼Œæ‰€æœ‰ä¸ä¼šå…±è¡Œ
    * */
    private static boolean isValid(int[] record, int i, int j) {
        for (int k = 0; k < i; k++) {//iè¡Œä¹‹å‰çš„æŸä¸ªkè¡Œçš„çš‡å
            if (record[k]==j || Math.abs(i-k)==Math.abs(record[k]-j)){
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        num(14);
        System.out.println("cost time :"+(System.currentTimeMillis() - start)+"ms");

    }
}

```

## KMPç®—æ³•

```java
/*
* KMPç®—æ³•
* */
public class KMP {
    public static int getIndexOf(String s1,String s2){
        if (s1==null || s2==null || s2.length()<1 || s2.length()>s1.length()){
            return -1;
        }
        int i1=0;
        int i2=0;
        int[] next= getNextArray(s2.toCharArray());//O(M)
        //O(N)
        while (i1<s1.length()&&i2<s2.length()){
            if (s1.charAt(i1)==s2.charAt(i2)){
                i1++;
                i2++;
            } else if (next[i2] == -1) {
                i1++;
            }else{
                i2=next[i2];
            }
        }
        return i2==s2.length()?i1-i2:-1;
    }

    private static int[] getNextArray(char[] chars) {
        if (chars.length==1){
            return new int[]{-1};
        }
        int[] next=new int[chars.length];
        next[0]=-1;
        next[1]=0;
        int i=2;
        int cn=0;//int cn=next[1];
        while (i<next.length){
            if (chars[i-1]==chars[cn]){
                next[i++]=++cn;
            }else if(cn>0){
                cn=next[cn];
            }else{
                next[i++]=0;
            }
        }
        return next;
    }
}

```

## Manacherç®—æ³•

```java
package datastructures;
/*
* æ±‚æœ€å¤§å›æ–‡ä¸²é•¿åº¦
* */
public class Manacher {

    /*
    * ç”¨'#'å¯¹åŸå§‹å­—ç¬¦ä¸²è¿›è¡Œå¡«å……
    * */
    public static char[] manacherString(String str){
        char[] chars = str.toCharArray();
        char[] res=new char[str.length()*2+1];
        int index=0;
        for (int i = 0; i < res.length; i++) {
            res[i]=(i & 1)==0?'#':chars[index++];
        }
        return res;
    }

    public static int maxLcpsLength(String str){
        char[] chars = manacherString(str);//å¾—åˆ°å¡«å……åçš„å­—ç¬¦ä¸²
        int[] pArr=new int[chars.length];
        int r=-1;//æ‰€æœ‰ä»¥cä¸ºä¸­å¿ƒæ‰©çš„å›æ–‡ä¸²ä¸­æœ€é å³çš„å³è¾¹ç•Œ+1
        int c=-1;
        int max=Integer.MIN_VALUE;
        for (int i = 0; i < chars.length; i++) {
            //å…ˆæ‰¾å‡ºä¸éœ€è¦è€ƒè™‘çš„èŒƒå›´
           pArr[i]= r>i?Math.min(r-i,pArr[c*2-i]):1;// i>=ræ—¶ï¼ŒpArr[i]=1æš´åŠ›æ‰©ï¼ä¸ç”¨è€ƒè™‘çš„åŒºåŸŸåªæœ‰è‡ªå·±
            //r>iæ—¶ï¼Œiåˆ†åœ¨è¾¹ç•Œä¸Šå’Œè¾¹ç•Œå†…ä¸¤ç§æƒ…å†µï¼Œåœ¨è¾¹ç•Œä¸Šé‚£ä¹ˆpArr[i]=r-i=1ï¼ˆå› ä¸ºr-i<=pArr[c*2-i])
            // è¾¹ç•Œå†…é‚£ä¹ˆå°±æ˜¯Math.min(r-i,pArr[c*2-i])
           while (i+pArr[i]<chars.length && i-pArr[i]>-1){
               if (chars[i+pArr[i]]==chars[i-pArr[i]]){
                   pArr[i]++;
               }else{
                   break;
               }
           }
           //åˆ¤æ–­æš´åŠ›æ‰©æœ‰æ²¡æœ‰æ‰©å‡ºæœ€å³è¾¹ç•Œï¼Œæœ‰åˆ™æ›´æ–°r
           if (i+pArr[i]>r){
               r=i+pArr[i];
               c=i;
           }
           //æ›´æ–°æœ€å¤§å›æ–‡åŠå¾„
           max=Math.max(max,pArr[i]);
        }
        //è¿”å›æœ€å¤§å›æ–‡ä¸²é•¿åº¦-ã€‹åŸå§‹ä¸²çš„æœ€å¤§å›æ–‡ä¸²é•¿åº¦=å¡«å……ä¸²çš„æœ€å¤§å›æ–‡åŠå¾„-1
        return max-1;
    }

    public static void main(String[] args) {
        System.out.println(maxLcpsLength("01213210"));
    }
}

```

## å¹¶æŸ¥é›†

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;
/*
* å¹¶æŸ¥é›†
* */
public class UnionFindSetDemo {

    public static class Element<V>{
        public V value;
        public Element(V value) {
            this.value = value;
        }
    }
    public static class UnionFindSet<V>{
        public HashMap<V,Element<V>> elementMap;
        public HashMap<Element<V>,Element<V>> fatherMap;
        public HashMap<Element<V>,Integer> sizeMap;

        public UnionFindSet(List<V> values) {
            this.elementMap=new HashMap<>();
            this.fatherMap=new HashMap<>();
            this.sizeMap=new HashMap<>();
            for (V value : values) {
                Element<V> element = new Element<>(value);
                elementMap.put(value,element);
                fatherMap.put(element,element);
                sizeMap.put(element,1);
            }
        }

        public boolean isSameSet(V a, V b){
            if (elementMap.containsKey(a) && elementMap.containsKey(b)){
                return findHeap(elementMap.get(a)) == findHeap(elementMap.get(b));
            }
            return false;
        }

        public void union(V a,V b){
            if (elementMap.containsKey(a) && elementMap.containsKey(b)){
                if (!isSameSet(a, b)){
                    Element<V> heap1 = findHeap(elementMap.get(a));
                    Element<V> heap2 = findHeap(elementMap.get(b));
                    Element<V> big = sizeMap.get(heap1) > sizeMap.get(heap2) ? heap1 : heap2;
                    Element<V> small = big == heap1 ? heap2 : heap1;
                    fatherMap.put(small,big);
                    sizeMap.put(big,sizeMap.get(heap1)+sizeMap.get(heap2));
                    sizeMap.remove(small);
                }
            }
        }

        private Element<V> findHeap(Element<V> element) {
            Stack<Element<V>> path =new Stack<>();
            while (element!=fatherMap.get(element)){
                path.push(element);
                element=fatherMap.get(element);
            }
            while (!path.isEmpty()){
                fatherMap.put(path.pop(),element);
            }
            return element;
        }
    }

    public static void main(String[] args) {
        List<Integer> list=new ArrayList<>();
        for (Integer integer : list) {
            System.out.println(integer);
        }
    }
}

```

## æ»‘åŠ¨çª—å£é—®é¢˜

### æ±‚çª—å£ä¸­ä½æ•°

å¤§æ ¹å †å’Œå°æ ¹å † é£é™©å¯¹å†²

```java
package datastructures.heap;
/*
* æ»‘åŠ¨çª—å£æ±‚ä¸­ä½æ•°é—®é¢˜
* */
public class Solution {
    public static double[] medianSlidingWindow(int[] nums, int k) {
        if (nums==null|| k<1 || k>nums.length){
            return null;
        }
        double[] res=new double[nums.length-k+1];
        DualHeap dh=new DualHeap(k);
        for (int i = 0; i < k; i++) {
            dh.insert(nums[i]);
        }
        res[0]=dh.getMedian();
        for (int i = k; i < nums.length; i++) {
            dh.insert(nums[i]);
            dh.erase(nums[i-k]);//åˆ é™¤è¿‡æœŸçª—å£ä½ç½®
            res[i-k+1]=dh.getMedian();
        }
        return res;
    }

    public static void main(String[] args) {
        for (double v : medianSlidingWindow(new int[]{-2147483648,-2147483648,2147483647,-2147483648,-2147483648,
                -2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648}, 3)) {
            System.out.print(v+" ");
        }
    }
}

```

```java
package datastructures.heap;

import java.util.HashMap;
import java.util.PriorityQueue;
/*
* å®šä¹‰ä¸€ç§æ•°æ®ç»“æ„è§£å†³æ»‘åŠ¨çª—å£æ±‚ä¸­ä½æ•°é—®é¢˜
* */
public class DualHeap {
    private PriorityQueue<Integer> small;
    private PriorityQueue<Integer> large;
    private HashMap<Integer,Integer> delay;
    private int smallSize;
    private int largeSize;
    private int k;
    public DualHeap(int k){
        this.large=new PriorityQueue<>();
        this.small=new PriorityQueue<>( ( o1,o2) -> o2.compareTo(o1));//ç›´æ¥ç”¨å‡å·ä¼šå‡ºç°æº¢å‡ºï¼ï¼ï¼ğŸ˜‰ğŸ˜‰ğŸ¤·â€â™€ï¸
        this.delay=new HashMap<>();
        this.largeSize=0;
        this.smallSize=0;
        this.k=k;

    }
    /*
    * è·å–ä¸­ä½æ•°
    * */
    public double getMedian(){
        return (k&1)==1?
                (double)small.peek():
                ((double)small.peek()/2+(double) large.peek()/2);
    }
    /*
    * æ’å…¥æ•°æ®
    * */
    public void insert(int num){
        if (small.isEmpty() || num<=small.peek()){
            small.offer(num);
            ++smallSize;
        }else{
            large.offer(num);
            ++largeSize;
        }
        makeBalance();//æ¯æ¬¡åŠ å…¥ä¸€ä¸ªå…ƒç´ éƒ½è¦åˆ¤æ–­æ˜¯å¦éœ€è¦è°ƒæ•´
    }
    /*
    * å»¶è¿Ÿåˆ é™¤ï¼åœ¨è°ƒæ•´è¿‡ç¨‹ä¸­è¯¥å…ƒç´ åˆ°å †é¡¶æ—¶æ‰ä¼šçœŸæ­£ä»ç»“æ„ä¸­åˆ é™¤
    * ä½†æ˜¯å¤§æ ¹å †å’Œå°æ ¹å †çš„å¤§å°æ˜¯åˆ é™¤å…ƒç´ åçš„å®é™…å€¼ï¼Œä¼šä¸¥æ ¼æŒ‰ç…§è§„åˆ™åˆ†å¸ƒï¼Œ
    * å°½ç®¡å»¶è¿Ÿåˆ é™¤å †é¡¶å…ƒç´ å°±æ˜¯å®é™…çš„ä¸­ä½æ•°(kå¥‡æ•°æ—¶å¤§æ ¹å †çš„å †é¡¶ï¼›kå¶æ•°æ—¶å¤§æ ¹å †å’Œå°æ ¹å †å †é¡¶çš„å¹³å‡å€¼)
    * å»¶è¿Ÿå…ƒç´ åªè¦ä¸åœ¨å †é¡¶å‚ä¸è®¡ç®—ä¹Ÿä¸å½±å“å®é™…çš„æ•°æ®æ’åºå’Œåˆ†å¸ƒï¼Œå°±ä¸ä¼šå½±å“æœ€ç»ˆç»“æœ
    * */
    public void erase(int num){
        delay.put(num,delay.getOrDefault(num,0)+1);
        if (num<=small.peek()){
            --smallSize;
            if (num==small.peek()){//å¦‚æœè¦åˆ é™¤çš„å…ƒç´ åœ¨å †é¡¶ç›´æ¥åˆ é™¤
                prune(small);
            }
        }else{
            --largeSize;
            if (num==large.peek()){
                prune(large);
            }
        }
        makeBalance();//æ ¹æ®å®é™…çš„å †å¤§å°è¿›è¡Œè°ƒæ•´
    }
    /*
    * æ»¡è¶³small.size()-large.size()==1 kä¸ºå¥‡æ•° è¿™æ—¶small.peek()å°±æ˜¯ä¸­ä½æ•°
    * æˆ–è€… small.size()-large.size()==0 kä¸ºå¶æ•° è¿™æ—¶ä¸­ä½æ•°æ˜¯small.peek()å’Œlarge.peek()çš„å¹³å‡å€¼
    * */
    private void makeBalance() {
        if (smallSize-largeSize>1){
            large.offer(small.poll());
            --smallSize;
            ++largeSize;
            prune(small);//æ£€æŸ¥æ–°å †é¡¶æ˜¯ä¸æ˜¯å»¶è¿Ÿåˆ é™¤çš„ï¼Œå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆåœ¨å †é¡¶æ—¶åˆ é™¤
        }
        if (largeSize>smallSize){
            small.add(large.poll());
            ++smallSize;
            --largeSize;
            prune(large);//æ£€æŸ¥æ–°å †é¡¶æ˜¯ä¸æ˜¯å»¶è¿Ÿåˆ é™¤çš„ï¼Œå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆåœ¨å †é¡¶æ—¶åˆ é™¤
        }
    }
    // å¦‚æœå †é¡¶æ˜¯å»¶è¿Ÿåˆ é™¤è¿‡çš„å…ƒç´ ï¼Œä¸æ–­åœ°å¼¹å‡º heap çš„å †é¡¶å…ƒç´ ï¼Œå¹¶ä¸”æ›´æ–°å“ˆå¸Œè¡¨
    private void prune(PriorityQueue<Integer> heap) {
        while (!heap.isEmpty()){
            Integer num = heap.peek();
            if (delay.containsKey(num)){
                delay.put(num,delay.get(num)-1);
                if (delay.get(num)==0){//è¯¥å…ƒç´ å·²åˆ å¹²å‡€ï¼Œå¯ä»¥ç§»é™¤map
                    delay.remove(num);
                }
                heap.poll();//åªè¦åœ¨å †é¡¶å‡ºç°å»¶è¿Ÿåˆ é™¤è¿‡çš„å…ƒç´ ï¼Œè¶åœ¨å †é¡¶ï¼Œé©¬ä¸Šåˆ é™¤
            }else{
                break;
            }
        }
    }
}

```

### æ±‚çª—å£ä¸­æœ€å¤§å€¼

åŒç«¯é˜Ÿåˆ—

```java

/*
 * æ»‘åŠ¨çª—å£
 * ä½¿ç”¨åŒç«¯é˜Ÿåˆ—LinkedListï¼šä¸¤ç«¯æ—¢å¯ä»¥æ’å…¥ä¹Ÿå¯ä»¥åˆ é™¤
 * */
public class SlidingWindow {

    public static int[] get(int[] arr, int w) {
        if (arr == null || w < 1 || arr.length < w) {
            return null;
        }
        int[] res = new int[arr.length - w + 1];
        LinkedList<Integer> list = new LinkedList<>();
        int r = 0;
        int index = 0;
        while (r < arr.length) {
            //ä¸¥æ ¼ä¿è¯åŠ å…¥å…ƒç´ åä¿æŒæœ‰åº
            while (!list.isEmpty() && arr[r] >= arr[list.peekLast()]) {
                list.pollLast();
            }
            list.add(r);
            //ä¿è¯æœ€å¤§å€¼å±äºæœ‰æ•ˆèŒƒå›´
            if (list.peekFirst() == r - w) {
                list.pollFirst();
            }
            if (r - w + 1 >= 0) {//çª—å£å½¢æˆäº†
                res[index++] = arr[list.getFirst()];
            }
            r++;


 }
        return res;
    }

}
```

## æ¥é›¨æ°´é—®é¢˜

```java
package datastructures.stack;

import java.util.*;
import java.util.Stack;

/*
* å•è°ƒæ ˆ
* */
public class MonotoneStack {

    /*
    * æ¥é›¨æ°´é—®é¢˜
    * */
    public static int trap(int[] height) {
        int res=0;
        java.util.Stack<Integer> stack = new java.util.Stack<>();
        for (int i = 0; i < height.length; ) {
            if (stack.isEmpty() || height[i] <= height[stack.peek()]) {
                stack.push(i);
                i++;
            } else {
                int midHeight=height[stack.pop()];
                int leftHeight=!stack.isEmpty()?height[stack.peek()]:0;
                int leftIndex=!stack.isEmpty()?stack.peek():-1;
                if (leftHeight>midHeight){
                    res+=(i-leftIndex-1)*(Math.min(leftHeight,height[i])-midHeight);
                }
            }
        }
        return res;
    }

    public static HashMap<Integer, List<Integer>> get(int[] arr) {
        java.util.Stack<Integer> stack = new java.util.Stack<>();
        HashMap<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < arr.length; ) {
            if (stack.isEmpty() || arr[i] > arr[stack.peek()]) {
                stack.push(i);
                i++;
            } else {
                Integer index = stack.pop();
                ArrayList<Integer> list = new ArrayList<>();
                list.add(!stack.isEmpty()?stack.peek():-1);//å·¦è¾¹æ¯”è‡ªå·±å°ä¸”æœ€è¿‘çš„ä½ç½®
                list.add(i);//å³è¾¹æ¯”è‡ªå·±å°çš„ä½ç½®
                map.put(index, list);
            }
        }
        //æœ€åç»“ç®—
        while (!stack.isEmpty()){
            Integer index = stack.pop();
            ArrayList<Integer> list = new ArrayList<>();
            list.add(!stack.isEmpty()?stack.peek():-1);//å·¦è¾¹æ¯”è‡ªå·±å°ä¸”æœ€è¿‘çš„ä½ç½®
            list.add(-1);//å³è¾¹æ¯”è‡ªå·±å°çš„ä½ç½®
            map.put(index, list);
        }
        return map;
    }

    public static HashMap<Integer, List<Integer>> get2(int[] arr) {
        java.util.Stack<LinkedList<Integer>> stack = new Stack<>();
        HashMap<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < arr.length; ) {
            if (stack.isEmpty() || arr[i] > arr[stack.peek().peekLast()]) {
                LinkedList<Integer> list= new LinkedList<>();
                list.offerLast(i++);
                stack.push(list);
            }else if(arr[i] == arr[stack.peek().peekLast()]){
                stack.peek().offerLast(i++);
            } else {
                LinkedList<Integer> list=stack.pop();
                while (!list.isEmpty()){
                    int index=list.pollLast();
                    ArrayList<Integer> res = new ArrayList<>();
                    res.add(!stack.isEmpty()?stack.peek().peekLast():-1);//å·¦è¾¹æ¯”è‡ªå·±å°ä¸”æœ€è¿‘çš„ä½ç½®
                    res.add(i);//å³è¾¹æ¯”è‡ªå·±å°çš„ä½ç½®
                    map.put(index, res);
                }
            }
        }
        //æœ€åç»“ç®—
        while (!stack.isEmpty()){
            LinkedList<Integer> list=stack.pop();
            while (!list.isEmpty()){
                int index=list.pollLast();
                ArrayList<Integer> res = new ArrayList<>();
                res.add(!stack.isEmpty()?stack.peek().peekLast():-1);//å·¦è¾¹æ¯”è‡ªå·±å°ä¸”æœ€è¿‘çš„ä½ç½®
                res.add(-1);//å³è¾¹æ¯”è‡ªå·±å°çš„ä½ç½®
                map.put(index, res);
            }
        }
        return map;
    }

    public static void main(String[] args) {
        int[] arr={5, 4, 4,2,2,6, 7, 2, 3, 0, 1};
        HashMap<Integer, List<Integer>> map = get2(arr);
        for (Integer key : map.keySet()) {
            System.out.println(arr[key]+" å·¦"+map.get(key).get(0)+" å³ "+map.get(key).get(1));
        }

        System.out.println(trap(new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}));

    }
}

```

## æ ‘å½¢dp

```java
package datastructures.violentRecursion;
import datastructures.tree.TreeNode;

import java.util.HashMap;
/*
* æ ‘å½¢dp
* */
public class MaxDistance {
    public static int maxDistance(TreeNode head){
        return process(head).maxDistance;
    }
    public static class Info{
        private int maxDistance;
        private int height;

        public Info(int distance, int height) {
            this.maxDistance = distance;
            this.height = height;
        }
    }
    public static Info process(TreeNode head){
        if (head==null){
            return new Info(0,0);//ä¸€å®šè¦é€‰å¥½baseCase
        }
        Info leftInfo = process(head.left);
        Info rightInfo = process(head.right);
        int height=Math.max(leftInfo.height,rightInfo.height)+1;
        int maxDistance=Math.max(leftInfo.maxDistance,rightInfo.maxDistance);
        maxDistance=Math.max(maxDistance,leftInfo.height+rightInfo.height+1);
        return new Info(maxDistance,height);
    }

    public static HashMap<String,Integer> processX(TreeNode head){
        HashMap<String,Integer> infoMap=new HashMap<>();
        if (head==null){
            infoMap.put("height",0);
            infoMap.put("distance",0);
            return infoMap;
        }
        HashMap<String, Integer> leftInfo = processX(head.left);
        HashMap<String, Integer> rightInfo = processX(head.right);
        infoMap.put("height", Math.max(leftInfo.get("height"),rightInfo.get("height"))+1);
        int maxDistance=Math.max(leftInfo.get("maxDistance"),rightInfo.get("maxDistance"));
        maxDistance=Math.max(maxDistance,leftInfo.get("height")+rightInfo.get("height")+1);
        infoMap.put("distance",maxDistance);
        return infoMap;
    }
}

```

## æ´¾å¯¹æœ€å¤§å¿«ä¹å€¼

```java
package datastructures.violentRecursion;

import java.util.List;
/*
* æ´¾å¯¹æœ€å¤§å¿«ä¹å€¼
* */
public class Happy {

    public static class Employee{
        public int happy;
        List<Employee> subordinates;

        public Employee(int happy, List<Employee> subordinates) {
            this.happy = happy;
            this.subordinates = subordinates;
        }
    }

    public static class Info{
        private int joinMax;
        private int  unJoinMax;

        public Info(int joinMax, int unJoinMax) {
            this.joinMax = joinMax;
            this.unJoinMax = unJoinMax;
        }
    }

    public static int getMaxHappy(Employee employee){
        Info info = process(employee);
        return Math.max(info.joinMax,info.unJoinMax);
    }
    public static Info process(Employee employee){
        if (employee.subordinates==null){//åŸºå±‚å‘˜å·¥
            return new Info(employee.happy,0);
        }
        int joinMax=employee.happy;
        int unJoinMax=0;
        for (Employee subordinate : employee.subordinates) {
            Info info = process(subordinate);
            joinMax+=info.unJoinMax;
            unJoinMax+=Math.max(info.joinMax,info.unJoinMax);
        }
        return new Info(joinMax,unJoinMax);
    }

    public static int process2(Employee employee, boolean join){
        if (employee==null){
            return 0;
        }
        //å½“å‰å‘˜å·¥ä¸èƒ½å‚ä¸æ´»åŠ¨
        if (!join){
            int res=0;
            for (Employee subordinate : employee.subordinates) {
                res+=Math.max(process2(subordinate,true), process2(subordinate,false));
            }
            return res;
        }
        //å½“å‰å‘˜å·¥å¯å‚ä¸ä¹Ÿå¯ä¸å‚ä¸æ´»åŠ¨
        //1.é€‰æ‹©å‚ä¸
        int res1=0;
        res1+=employee.happy;
        for (Employee subordinate : employee.subordinates) {
            res1+= process2(subordinate,false);
        }
        //2.é€‰æ‹©ä¸å‚ä¸
        int res2=0;
        for (Employee subordinate : employee.subordinates) {
            res2+=Math.max(process2(subordinate,true), process2(subordinate,false));
        }
        return Math.max(res1,res2);


    }

}

```

## Morriséå†

```java
package datastructures.tree;
/*
* MorrisNodeå®ç°äºŒå‰æ ‘éå†
* ä¸æ˜¯ç³»ç»Ÿå‹æ ˆï¼Œæ˜¯æ”¹å˜å¶èŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘
* */
public class MorrisNode {
    public static void morrisNode(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//è¿‡æµç¨‹
            mostRight=cur.left;//æ‰¾curå·¦å­æ ‘ä¸Šçš„æœ€å³èŠ‚ç‚¹ï¼Œä»å·¦å­æ ‘å¤´èŠ‚ç‚¹å¼€å§‹å¯»æ‰¾mostRight
            if (mostRight!=null){//æœ‰å·¦å­æ ‘
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//è¿™æ˜¯ç¬¬ä¸€æ¬¡æ¥åˆ°cur
                    System.out.println(cur.val);
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//ä¹‹å‰æ¥è¿‡cur,æ¥ä¸‹æ¥è¦ç§»åˆ°cur.right
                }
            }
            cur=cur.right;//curæ²¡æœ‰å·¦å­æ ‘æˆ–è€…å·²ç»èµ°å®Œå·¦å­æ ‘
        }

    }

    /*
    * morriså®ç°äºŒå‰æ ‘å…ˆåºéå†
    * */
    public static void morrisPre(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//è¿‡æµç¨‹
            mostRight=cur.left;//æ‰¾curå·¦å­æ ‘ä¸Šçš„æœ€å³èŠ‚ç‚¹ï¼Œä»å·¦å­æ ‘å¤´èŠ‚ç‚¹å¼€å§‹å¯»æ‰¾mostRight
            if (mostRight!=null){//æœ‰å·¦å­æ ‘
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//è¿™æ˜¯ç¬¬ä¸€æ¬¡æ¥åˆ°cur
                    System.out.println(cur.val);
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//ä¹‹å‰æ¥è¿‡cur,æ¥ä¸‹æ¥è¦ç§»åˆ°cur.right
                }
            }else{
                System.out.println(cur.val);
            }
            cur=cur.right;//curæ²¡æœ‰å·¦å­æ ‘æˆ–è€…å·²ç»èµ°å®Œå·¦å­æ ‘
        }

    }

    /*
     * morriså®ç°äºŒå‰æ ‘ä¸­åºéå†
     * */
    public static void morrisIn(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//è¿‡æµç¨‹
            mostRight=cur.left;//æ‰¾curå·¦å­æ ‘ä¸Šçš„æœ€å³èŠ‚ç‚¹ï¼Œä»å·¦å­æ ‘å¤´èŠ‚ç‚¹å¼€å§‹å¯»æ‰¾mostRight
            if (mostRight!=null){//æœ‰å·¦å­æ ‘
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//è¿™æ˜¯ç¬¬ä¸€æ¬¡æ¥åˆ°cur
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//ä¹‹å‰æ¥è¿‡cur,æ¥ä¸‹æ¥è¦ç§»åˆ°cur.right
                }
            }
            System.out.println(cur.val);//ç¬¬äºŒæ¬¡æ¥åˆ°curå’Œæ²¡æœ‰å·¦å­æ ‘æ—¶æ‰“å°
            cur=cur.right;//curæ²¡æœ‰å·¦å­æ ‘æˆ–è€…å·²ç»èµ°å®Œå·¦å­æ ‘
        }

    }

    /*
     * morriså®ç°äºŒå‰æ ‘ååºéå†
     * */
    public static void morrisAfter(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//è¿‡æµç¨‹
            mostRight=cur.left;//æ‰¾curå·¦å­æ ‘ä¸Šçš„æœ€å³èŠ‚ç‚¹ï¼Œä»å·¦å­æ ‘å¤´èŠ‚ç‚¹å¼€å§‹å¯»æ‰¾mostRight
            if (mostRight!=null){//æœ‰å·¦å­æ ‘
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//è¿™æ˜¯ç¬¬ä¸€æ¬¡æ¥åˆ°cur
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//ä¹‹å‰æ¥è¿‡cur,æ¥ä¸‹æ¥è¦ç§»åˆ°cur.right
                    printEdge(cur.left);//ç¬¬äºŒæ¬¡åˆ°è¾¾æŸèŠ‚ç‚¹æ—¶æ‰“å°è¯¥èŠ‚ç‚¹çš„å·¦å­æ ‘å³è¾¹ç•Œ
                }
            }
            cur=cur.right;//curæ²¡æœ‰å·¦å­æ ‘æˆ–è€…å·²ç»èµ°å®Œå·¦å­æ ‘
        }
        printEdge(head);//æœ€åæ‰“å°æ•´æ£µæ ‘çš„å³è¾¹ç•Œ
        System.out.println();

    }
    /*
    * é€†åºæ‰“å°ä»¥xä¸ºå¤´çš„è¿™é¢—æ ‘çš„å³è¾¹ç•Œ
    * */
    public static void printEdge(TreeNode x){
        TreeNode tail=reverse(x);
        TreeNode cur=tail;
        while (cur!=null){
            System.out.print(x.val+" ");
            cur=cur.right;
        }
        reverse(tail);
    }

    private static TreeNode reverse(TreeNode from) {
        TreeNode pre=null;
        TreeNode next =null;
        while (from !=null){
            next = from.right;
            from.right=pre;
            pre= from;
            from = next;
        }
        return pre;
    }
}
```

## å“ˆå¸Œè¡¨

1. HashSet 
   åªæœ‰keyï¼Œæ²¡æœ‰ä¼´éšæ•°æ®value

2. HashMap
   æ—¢æœ‰keyï¼Œåˆæœ‰ä¼´éšæ•°æ®value

ä½¿ç”¨å“ˆå¸Œè¡¨è¿›è¡Œå¢åˆ æ”¹æŸ¥éƒ½å¯ä»¥è®¤ä¸ºæ˜¯æ—¶é—´å¤æ‚åº¦ä¸ºO(1)çº§åˆ«ï¼Œä½†æ˜¯å¸¸ç†Ÿæ—¶é—´æ¯”è¾ƒå¤§ï¼›æ”¾å…¥å“ˆå¸Œè¡¨çš„ä¸œè¥¿å¦‚æœæ˜¯åŸºç¡€ç±»å‹ï¼Œå†…éƒ¨æŒ‰å€¼ä¼ é€’ï¼Œå†…å­˜å ç”¨å°±æ˜¯è¿™ä¸ªä¸œè¥¿çš„å¤§å°ï¼Œå¦‚æœä¸æ˜¯åŸºç¡€ç±»å‹ï¼Œå†…å­˜å ç”¨çš„å°±æ˜¯è¿™ä¸ªä¸œè¥¿å†…å­˜åœ°å€çš„å¤§å°ã€‚

### RandomPoolç»“æ„

```java
package hash;

import java.util.HashMap;
import java.util.Random;
/*
* è®¾è®¡ä¸€ä¸ªRandomPollç»“æ„
* insert(key)ä¸é‡å¤åŠ å…¥key
* delete(key)ç§»é™¤key
* getRandom()ç­‰æ¦‚ç‡éšæœºè¿”å›ç»“æ„ä¸­çš„ä»»ä½•ä¸€ä¸ªkey
* æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯key
* */
public class RandomPoll<K>{
    private HashMap<K,Integer> keyIndexMap;
    private HashMap<Integer,K> indexKeyMap;
    private int size;

    public RandomPoll(){
        this.keyIndexMap = new HashMap<>();
        this.indexKeyMap = new HashMap<>();
        this.size = 0;
    }
    public RandomPoll(HashMap<K, Integer> keyIndexMap, HashMap<Integer, K> indexKeyMap, int size) {
        this.keyIndexMap = keyIndexMap;
        this.indexKeyMap = indexKeyMap;
        this.size = size;
    }
    /*
     * æ’å…¥key
     * */
    public void insert(K key){
        if (!keyIndexMap.containsKey(key)){
            keyIndexMap.put(key,size);
            indexKeyMap.put(size++,key);
        }
    }
    /*
     * åˆ é™¤key
     * */
    public void delete(K key){
        //åˆ é™¤å‰åˆ¤æ–­keyæ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­
        if (keyIndexMap.containsKey(key)){
            Integer index = keyIndexMap.get(key);
            keyIndexMap.put(indexKeyMap.get(size-1),index);
            indexKeyMap.put(index,indexKeyMap.get(size-1));
            keyIndexMap.remove(key);
            indexKeyMap.remove(--size);
        }
    }
    /*
     * ç­‰æ¦‚ç‡éšæœºè¿”å›ç»“æ„ä¸­çš„ä»»ä½•ä¸€ä¸ªkey
     * */
    public K getRandom(){
        Random r=new Random();
        int randomIndex = r.nextInt(size);
//            int randomIndex = (int)(Math.random() * this.size);//0~size-1
        return indexKeyMap.get(randomIndex);
    }
}

```

## æœ‰åºè¡¨

1. TreeSet
   åªæœ‰keyï¼Œæ²¡æœ‰ä¼´éšæ•°æ®value

2. TreeMap
   æ—¢æœ‰keyï¼Œåˆæœ‰ä¼´éšæ•°æ®value

å“ˆå¸Œè¡¨å’Œæœ‰åºè¡¨çš„åŒºåˆ«æ˜¯ï¼Œæœ‰åºè¡¨æŠŠkeyæŒ‰ç…§é¡ºåºç»„ç»‡èµ·æ¥ï¼Œå“ˆå¸Œè¡¨çš„keyåˆ™æ²¡æœ‰é¡ºåºï¼›æ”¾å…¥æœ‰åºè¡¨çš„ä¸œè¥¿å¦‚æœæ˜¯åŸºç¡€ç±»å‹ï¼Œå†…éƒ¨æŒ‰å€¼ä¼ é€’ï¼Œå†…å­˜å ç”¨å°±æ˜¯è¿™ä¸ªä¸œè¥¿çš„å¤§å°ï¼Œå¦‚æœä¸æ˜¯åŸºç¡€ç±»å‹ï¼Œå¿…é¡»æä¾›æ¯”è¾ƒå™¨ï¼Œå†…å­˜å ç”¨çš„å°±æ˜¯è¿™ä¸ªä¸œè¥¿å†…å­˜åœ°å€çš„å¤§å°ï¼›æœ‰åºè¡¨çš„æ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(logN),Nä¸ºæœ‰åºè¡¨å«æœ‰çš„è®°å½•æ•°ã€‚





## æš´åŠ›é€’å½’

### æ±‰è¯ºå¡”

```java
package violentRecursion;

/*
 *  æš´åŠ›é€’å½’
 *  å“ˆè¯ºå¡”ç»å…¸é—®é¢˜
 * */
public class Hanoi {
    public static void hanoi(int n) {
        process(n, "å·¦", "å³", "ä¸­");
    }

    private static void process(int n, String start, String end, String other) {
        if (n == 1) {
            System.out.println("Move 1 from " + start + " to " + end);
            return;
        }

        process(n - 1, start, other, end);
        System.out.println("Move " + n + " from " + start + " to " + end);
        process(n - 1, other, end, start);

    }

    public static void main(String[] args) {
        hanoi(15);
    }
}

```

### çº¸ç‰Œ

```java

package violentRecursion;

/*
* æš´åŠ›é€’å½’
* æ•°å€¼ä¸åŒçš„ç‰Œæ’æˆä¸€æ¡çº¿ï¼Œç©å®¶Aå’Œç©å®¶Bä¾æ¬¡æ‹¿èµ°æ¯ä¸€å¼ ç‰Œï¼Œè§„å®šç©å®¶Aå…ˆæ‹¿ï¼Œç©å®¶Båæ‹¿
* ä¸€ä¸ªç©å®¶åªèƒ½æ‹¿èµ°æœ€å·¦æˆ–æœ€å³çš„ç‰Œï¼Œç©å®¶Aå’Œç©å®¶Béƒ½ç»é¡¶èªæ˜ï¼Œè¯·è¿”å›æœ€åè·èƒœè€…çš„åˆ†æ•°
* */
public class CardsInline {
    public static int win(int[] arr){
        if (arr==null || arr.length==0){
            return 0;
        }
        //0åˆ°arr.length-1èŒƒå›´ä¸Šï¼Œä¸€ä¸ªç©å®¶å½“å…ˆæ‰‹ï¼Œå¦ä¸€ä¸ªç©å®¶å½“åæ‰‹
        return Math.max(first(arr,0,arr.length-1),second(arr,0,arr.length-1));
    }
    //å…ˆæ‰‹ç©å®¶
    public static int first(int[] arr,int l,int r){
        if (l==r){
            return arr[l];
        }
        //ä½œä¸ºå…ˆæ‰‹ï¼Œæˆ‘ä¼šé€‰æ‹©å¯¹æˆ‘è‡ªå·±æœ€æœ‰åˆ©çš„ï¼Œæ‰€ä»¥é€‰max
        return Math.max(arr[l]+second(arr,l+1,r),arr[r]+second(arr,l,r-1));
    }
    //åæ‰‹ç©å®¶
    public static int second(int[] arr,int l,int r){
//        å¦‚æœl==rï¼Œä½œä¸ºåæ‰‹ï¼Œè¿™å”¯ä¸€çš„ç‰Œä¼šè¢«å…ˆæ‰‹æ‹¿èµ°ï¼Œæ‰€ä»¥åªèƒ½è¿”å›0
        if (l==r){
            return 0;
        }
        //ä½œä¸ºåæ‰‹ï¼Œå…ˆæ‰‹ä¼šæŠŠæœ€åçš„æƒ…å†µç»™æˆ‘ï¼Œæ‰€ä»¥é€‰min
        return Math.min(first(arr,l+1,r),first(arr,l,r-1));
    }
}

```

### æ‰“å°æ‰€æœ‰æ’åˆ—

```java
package violentRecursion;

import java.util.ArrayList;

/*
 * æš´åŠ›é€’å½’
 * æ‰“å°æ‰€æœ‰æ’åˆ—
 * */
public class PrintAllPermutations {

    public static void process(char[] str, int i, ArrayList<String> res) {
        if (i == str.length) {
            res.add(String.valueOf(str));
            return;
        }
        boolean[] visit = new boolean[26];//visit[0]=true è¯´æ˜aå‚ä¸è¿‡äº¤æ¢ visit[1]=trueè¯´æ˜bå‚ä¸è¿‡äº¤æ¢
        // æ˜¯ä¸ºäº†é¿å…iä½ç½®å’Œä¸åŒä½ç½®å´ç›¸åŒå­—ç¬¦çš„ä½ç½®äº¤æ¢ï¼Œæœ€ç»ˆäº§ç”Ÿç›¸åŒçš„å­—ç¬¦ä¸²
        for (int j = i; j < str.length; j++) {
            if (!visit[str[j] - 'a']) {
                visit[str[j] - 'a'] = true;
                swap(str, i, j);
                process(str, i + 1, res);
                swap(str, i, j);
            }
        }
    }

    private static void swap(char[] str, int i, int j) {
        char temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }

    public static void main(String[] args) {
        String str = "abca";
        char[] chars = str.toCharArray();
        ArrayList<String> list = new ArrayList<>();
        process(chars, 0, list);
        for (String s : list) {
            System.out.println(s);
        }
    }
}

```

### å­—ç¬¦ä¸²å­åºåˆ—

```java
package violentRecursion;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.Collectors;

/*
* æš´åŠ›é€’å½’
* æ‰“å°ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ‰€æœ‰å­åºåˆ—ï¼ŒåŒ…æ‹¬ç©ºå­—ç¬¦ä¸²
* */
public class SubsequenceOfString {
    public static void function(String str){

        ArrayList<Character> res = new ArrayList<>();
        char[] chars = str.toCharArray();
        process(0,chars,res);
        process2(chars,0);
    }
    public static ArrayList<String> strings=new ArrayList<>();
    private static void process(int i, char[] chars, ArrayList<Character> res) {
        if (i==chars.length){
            /*if (!res.isEmpty()){
                String str = res.stream().map(Object::toString).collect(Collectors.joining());
                strings.add(str);
            }else{
                strings.add("");
            }*/
            String str = res.stream().map(Object::toString).collect(Collectors.joining());
            strings.add(str);
            return;
        }
//        ArrayList<Character> yes=res;//è¿™æ˜¯å¼•ç”¨å•Šå¤§å‚»å¦å§æ§½ï¼ï¼ï¼ä¹Ÿä¼šæ”¹å˜resçš„å€¼
        ArrayList<Character> yes=copy(res);
        yes.add(chars[i]);
        process(i+1,chars,yes);
        ArrayList<Character> no=copy(res);
        process(i+1,chars,no);
    }
    private static ArrayList<Character> copy(ArrayList<Character> res) {
        return new ArrayList<>(res);//ä¸€å®šè¦newä¸€ä¸ªæ–°çš„listï¼Œä¸ç„¶å°±æ˜¯å¯¹åŸé›†åˆçš„å¼•ç”¨ï¼Œä¼šæ”¹å˜åŸé›†åˆçš„å€¼
    }

    /*
    * æ¥åˆ°å½“å‰ä½ç½®ï¼Œè¦å’Œä¸è¦ï¼Œèµ°ä¸¤æ¡è·¯
    * ä¹‹å‰çš„é€‰æ‹©å½¢æˆçš„ç»“æœæ˜¯str
    * */
    public static void process2(char[] str,int i){
        if (i==str.length){
            System.out.println(Arrays.toString(str));
            return;
        }
        process2(str,i+1);//è¦å½“å‰çš„å­—ç¬¦
        char temp=str[i];
        str[i]=0;
        process2(str,i+1);//ä¸è¦å½“å‰çš„å­—ç¬¦
        str[i]=temp;
    }

    public static void main(String[] args) {
        function("abc");
        for (String string : strings) {
            System.out.println(string);
        }
        System.out.println(strings.size());
    }
}

```

### æ•°å­—å­—ç¬¦ä¸²

```java
package violentRecursion;
/*
* è§„å®š1å¯¹åº”Aï¼Œ2å¯¹åº”Bï¼Œ3å’ŒCå¯¹åº”ä»¥æ­¤ç±»æ¨
* é‚£ä¹ˆä¸€ä¸ªæ•°å­—å­—ç¬¦ä¸²"111",å°±å¯ä»¥è½¬åŒ–æˆ"AAA","KA","AK"
* è¿”å›æœ‰å¤šå°‘ç§è½¬åŒ–ç»“æœ
* * */
public class ConvertToLetterString {

    public static void function(String str){
        char[] chars = str.toCharArray();
        StringBuilder sb=new StringBuilder();
        System.out.println("æ€»å…±æœ‰"+s(chars, 0, sb)+"ç§ç»„åˆæ–¹å¼");
    }
    public static int s(char[] str,int i,StringBuilder sb){
        if (i==str.length){
            System.out.println(sb.toString());
            return 1;
        }
        if (str[i]=='0'){
            sb.delete(0,sb.length());
            return 0;
        }
        if (str[i]=='1'){
            StringBuilder sb1=new StringBuilder();
            sb1.append(sb.toString());
            sb1.append(getChar(str[i]));//åŠ å…¥str[i]å¯¹åº”çš„å­—ç¬¦
            int res=s(str,i+1,sb1);
            if (i+1<str.length){
                StringBuilder sb2=new StringBuilder();
                sb2.append(sb.toString());
                sb2.append(getAppendChar(str[i],str[i+1]));
                res+=s(str,i+2,sb2);
            }
            return res;
        }
        if (str[i]=='2'){
            StringBuilder sb1=new StringBuilder();
            sb1.append(sb.toString());
            sb1.append(getChar(str[i]));//åŠ å…¥str[i]å¯¹åº”çš„å­—ç¬¦
            int res=s(str,i+1,sb1);
            if (i+1<str.length&&str[i+1]>='0'&&str[i+1]<='6'){
                StringBuilder sb2=new StringBuilder();
                sb2.append(sb.toString());
                sb2.append(getAppendChar(str[i],str[i+1]));//åŠ å…¥str[str[i]+str[i]]å¯¹åº”çš„å­—ç¬¦
                res+=s(str,i+2,sb2);
            }
            return res;
        }
        StringBuilder sb1=new StringBuilder();
        sb1.append(sb.toString());
        sb1.append(getChar(str[i]));//åŠ å…¥str[i]å¯¹åº”çš„å­—ç¬¦
        return s(str,i+1,sb1);
    }

    private static char getAppendChar(char c1, char c2) {
        int i = Character.getNumericValue(c1) * 10 + Character.getNumericValue(c2);
        return (char) ('A'+i-1);
    }

    public static char getChar(char c){
        int num = Character.getNumericValue(c);
        return (char) ('A'+num-1);
    }

    public static void main(String[] args) {
        function("21112331");
    }
}

```

### è¢‹å­è£…ç‰©å“

```java
package violentRecursion;
/*
* weights[i]å’Œvalues[i]åˆ†åˆ«ç»™ä»£è¡¨iå·ç‰©å“çš„é‡é‡å’Œä»·å€¼ï¼Œbagè¡¨ç¤º
* ä¸€ä¸ªè½½é‡bagçš„è¢‹å­ï¼Œæ‰€è£…ç‰©å“çš„é‡é‡ä¸èƒ½è¶…è¿‡è¿™ä¸ªé‡é‡
* */
public class Knapsack {

    public static int process(int[] weights,int[] values,int i,int bag,int usedWeight){
        if (usedWeight>bag){
            return -values[i-1];
        }
        if (i==weights.length){
            return 0;
        }
        //å¯ä»¥è£…
        return Math.max(values[i]+process(weights,values,i+1,bag,usedWeight+weights[i]),
                process(weights,values,i+1,bag,usedWeight));
    }

    public static int process2(int[] weights,int[] values,int i,int bag,
                               int alreadyWeight,int alreadyValue){
        if (alreadyWeight>bag){
            return 0;
        }
        if (i==weights.length){
            return alreadyValue;
        }
        //å¯ä»¥è£…
        return Math.max(
                process2(weights,values,i+1,bag,alreadyWeight+weights[i],alreadyValue+values[i]),
                process2(weights,values,i+1,bag,alreadyWeight,alreadyValue)
        );
    }

    public static void main(String[] args) {
        int[] weights={12,13,1,24,56,23};
        int[] values={12,13,15,16,18,120};
        System.out.println(process(weights, values, 0, 130,0));
        System.out.println(process2(weights,values,0,130,0,0));
    }
}

```











## å•é“¾è¡¨

* éå¸¸ç»å…¸çš„é¢˜ç›®ï¼ï¼ï¼
* ç»™å®šä¸¤ä¸ªæœ‰ç¯ä¹Ÿæœ‰å¯èƒ½æ— ç¯çš„å•é“¾è¡¨ï¼Œå¤´èŠ‚ç‚¹head1å’Œhead2ï¼Œè¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œå¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤ï¼Œè¯·è¿”å›ç¬¬ä¸€ä¸ªç›¸äº¤çš„èŠ‚ç‚¹ï¼Œå¦‚æœä¸ç›¸äº¤ï¼Œè¿”å›null
* è¦æ±‚ï¼šå¦‚æœä¸¤ä¸ªé“¾è¡¨é•¿åº¦å’Œä¸ºNï¼Œæ—¶é—´å¤æ‚åº¦è¯·è¾¾åˆ°0(N),é¢å¤–çš„ç©ºé—´å¤æ‚åº¦è¯·è¾¾

```java
package Tips;
/*
* éå¸¸ç»å…¸çš„é¢˜ç›®ï¼ï¼ï¼
* ç»™å®šä¸¤ä¸ªæœ‰ç¯ä¹Ÿæœ‰å¯èƒ½æ— ç¯çš„å•é“¾è¡¨ï¼Œå¤´èŠ‚ç‚¹head1å’Œhead2ï¼Œè¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œ
* å¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤ï¼Œè¯·è¿”å›ç¬¬ä¸€ä¸ªç›¸äº¤çš„èŠ‚ç‚¹ï¼Œå¦‚æœä¸ç›¸äº¤ï¼Œè¿”å›null
* è¦æ±‚ï¼šå¦‚æœä¸¤ä¸ªé“¾è¡¨é•¿åº¦å’Œä¸ºNï¼Œæ—¶é—´å¤æ‚åº¦è¯·è¾¾åˆ°0(N),é¢å¤–çš„ç©ºé—´å¤æ‚åº¦è¯·è¾¾åˆ°O(1)
* */
public class FindFirstIntersectNode {
    public static class Node {
        Integer value;
        Node next;

        public Node() {
        }

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
    /*
    * æ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹
    * */
    public static Node findFirstIntersectNode(Node head1,Node head2){
        if (head1==null || head2==null){
            return null;
        }
        //å…ˆæ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„å…¥ç¯èŠ‚ç‚¹ï¼Œä»¥æ­¤åˆ¤æ–­æ˜¯å¦æœ‰ç¯
        Node loop1 = getLoopNode(head1);
        Node loop2 = getLoopNode(head2);
        //ç¬¬ä¸€ç§å¯èƒ½ï¼šä¸¤ä¸ªéƒ½æ— ç¯
        if (loop1==null && loop2==null){
            return noLoop(head1,head2);
        }
        //ç¬¬äºŒç§å¯èƒ½ï¼šä¸¤ä¸ªéƒ½æœ‰ç¯
        if (loop1!=null && loop2!=null) {
            bothLoop(head1,loop1,head2,loop2);
        }
        //ç¬¬ä¸‰ç§å¯èƒ½ï¼šä¸€ä¸ªæœ‰ç¯ï¼Œä¸€ä¸ªæ— ç¯ï¼Œè¿™ç§æƒ…å†µä¸‹ä¸å¯èƒ½å­˜åœ¨ç›¸äº¤èŠ‚ç‚¹
        return null;
    }
    /*
    * æ‰¾åˆ°ç¬¬ä¸€ä¸ªå…¥ç¯èŠ‚ç‚¹ï¼Œå¦‚æœæ— ç¯åˆ™è¿”å›null
    * */
    public static Node getLoopNode(Node head){
        //ç©ºé“¾è¡¨æˆ–è€…é“¾è¡¨èŠ‚ç‚¹ä¸è¶³3çš„æƒ…å†µä¸å¯èƒ½æœ‰ç¯
        if (head==null||head.next==null||head.next.next==null){
            return null;
        }
        //å¿«æ…¢æŒ‡é’ˆ
        Node n1=head.next;
        Node n2=head.next.next;
        //åˆ¤æ–­å¿«æ…¢æŒ‡é’ˆèƒ½ä¸èƒ½ç›¸é‡ï¼Œå¦‚æœç›¸é‡åˆ™è¯æ˜å­˜åœ¨ç¯
        while (n1!=n2){
            if (n2.next==null||n2.next.next==null){
                return null;
            }
            n1=n1.next;
            n2=n2.next.next;
        }
        //ç›¸é‡åï¼Œå¿«æŒ‡é’ˆè¿”å›åˆ°å¤´èŠ‚ç‚¹ä½ç½®ï¼Œä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶ç§»åŠ¨ï¼Œæ­¥é•¿å‡ä¸º1ï¼Œå†æ¬¡ç›¸é‡çš„åœ°æ–¹å°±æ˜¯ç¬¬ä¸€ä¸ªå…¥ç¯èŠ‚ç‚¹
        n2=head;
        while (n1!=n2){
            n1=n1.next;
            n2=n2.next;
        }
        return n1;
    }
    /*
    * å¦‚æœä¸¤ä¸ªé“¾è¡¨éƒ½æ— ç¯ï¼Œè¿”å›ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹ï¼Œå¦‚æœä¸ç›¸äº¤åˆ™è¿”å›null
    * */
    public static Node noLoop(Node head1,Node head2){
        if (head1==null || head2==null){
            return null;
        }
        Node n1 =head1;
        int n =0;
        while (n1.next !=null){
            n1 = n1.next;
            n++;
        }
        Node n2 =head2;
        while (n2.next !=null){
            n2 = n2.next;
            n--;
        }
        if (n1!=n2){
            return null;
        }
        //è§„å®šé•¿çš„ä¸ºn1
        n1=n>0?head1:head2;
        n2=n1==head1?head2:head1;
        n=Math.abs(n);
        while (n!=0){
            n1=n1.next;
            n--;
        }
        while (n1!=n2){
            n1=n1.next;
            n2=n2.next;
        }
        return n1;
    }
    /*
    * ä¸¤ä¸ªæœ‰ç¯é“¾è¡¨è¿”å›ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹ï¼Œå¦‚æœä¸ç›¸äº¤è¿”å›null
    * */
    public static Node bothLoop(Node head1,Node loop1,Node head2,Node loop2){
        //ä¸¤ä¸ªéƒ½æœ‰ç¯ï¼Œé‚£ä¹ˆå¯èƒ½æœ‰ç›¸åŒçš„ç¯ï¼Œæœ‰ç›¸åŒçš„ç¯æ—¶ï¼Œå…¥ç¯èŠ‚ç‚¹å¯èƒ½ç›¸åŒä¹Ÿå¯èƒ½ä¸ç›¸åŒï¼Œåˆ†ä¸¤ç§æƒ…å†µè®¨è®º
        //å…·æœ‰ä¸¤ä¸ªä¸åŒç¯æ—¶ä¸å¯èƒ½ç›¸äº¤
        Node cur1=null;
        Node cur2=null;
        if (loop1==loop2){
            //ç¬¬ä¸€ç§æƒ…å†µï¼Œä¸¤ä¸ªé“¾è¡¨æ‹¥æœ‰ç›¸åŒçš„å…¥ç¯èŠ‚ç‚¹ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªç›¸äº¤çš„èŠ‚ç‚¹åœ¨å…¥ç¯èŠ‚ç‚¹çš„å‰é¢éƒ¨åˆ†
            //ä»¥å…¥ç¯èŠ‚ç‚¹ä¸ºç»ˆæ­¢èŠ‚ç‚¹ï¼ŒæŒ‰ç…§ä¸¤ä¸ªæ— ç¯é“¾è¡¨çš„æ€è·¯å¯»æ‰¾ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹
            cur1=head1;
            cur2=head2;
            int n =0;
            while (cur1!=loop1){
                cur1=cur1.next;
                n++;
            }
            while (cur2!=loop2){
                cur2=cur2.next;
                n--;
            }
            cur1=n>0?head1:head2;
            cur2=cur1==head1?head2:head1;
            n=Math.abs(n);
            while (n!=0){
                cur1=cur1.next;
                n--;
            }
            while (cur1!=cur2){
                cur1=cur1.next;
                cur2=cur2.next;
            }
            return cur1;
        }else{
            //ä¸¤ä¸ªé“¾è¡¨æœ‰ä¸åŒçš„å…¥ç¯èŠ‚ç‚¹
            cur1=loop1.next;
            while (loop1!=cur1){
                if (cur1==loop2){
                    //ä¸¤ä¸ªé“¾è¡¨æœ‰ä¸åŒçš„å…¥ç¯èŠ‚ç‚¹ï¼Œä½†æ˜¯å…·æœ‰ç›¸åŒçš„ç¯
                    return loop1;
                }
                cur1=cur1.next;
            }
            //ä¸¤ä¸ªé“¾è¡¨æœ‰ä¸åŒçš„ç¯ï¼Œå…¥ç¯èŠ‚ç‚¹è‚¯å®šä¹Ÿä¸ç›¸åŒ
            return null;
        }
    }


    public static void main(String[] args) {
        Node end = new Node(0, null);
        Node n1 = new Node(1, end);
        Node n2 = new Node(2, n1);
        Node n3 = new Node(3, n2);
        Node n4 = new Node(4, n3);
        Node n5 = new Node(5, n4);
        Node n6 = new Node(6, n5);
        Node n61 = new Node(61, n6);
        Node n62 = new Node(62, n6);
        Node head1 = new Node(71, n61);
        Node n72 = new Node(72, n62);
        Node n82 = new Node(82, n72);
        Node n92= new Node(92, n82);
        Node head2= new Node(102, n92);
        end.next=n6;
        Node node = bothLoop(head1,n6, head2,n6);
        System.out.println(node.value);
    }
}

```

## äºŒå‰æ ‘

```java
package dataStructure;
import java.util.*;
import java.util.Queue;
import java.util.Stack;

/*
 * äºŒå‰æ ‘
 * ä¸‰ç§éå†æ–¹å¼+å±‚åºéå†
 * æ±‚æœ€å¤§å®½åº¦
 * */
public class BinaryTree {
    /*
     * äºŒå‰æ ‘èŠ‚ç‚¹
     * */
    private static class Node {
        Integer value;
        Node left;
        Node right;

        public Node(Integer value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    /*
     * é€’å½’å®ç°å‰åºéå†
     * */
    public static void preOrder(Node head) {
        if (head == null) {
            return;
        }
        System.out.print(head.value + " ");
        preOrder(head.left);
        preOrder(head.right);
    }

    /*
     * éé€’å½’å®ç°å‰åºéå†
     * */
    public static void preOrderUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            stack.push(head);
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.value + " ");
                if (head.right != null) {
                    stack.push(head.right);
                }
                if (head.left != null) {
                    stack.push(head.left);
                }
            }
        }
    }

    /*
     * é€’å½’å®ç°ä¸­åºéå†
     * */
    public static void inOrder(Node head) {
        if (head == null) {
            return;
        }
        inOrder(head.left);
        System.out.print(head.value + " ");
        inOrder(head.right);
    }

    /*
     * éé€’å½’å®ç°ä¸­åºéå†
     * */
    public static void inOrderUnRecur(Node head) {
        /*if (head != null) {
            Stack<Node> stack = new Stack<>();
            while (head != null) {
                stack.push(head);
                head = head.left;
            }
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.value + " ");
                head = head.right;
                while (head != null) {
                    stack.push(head);
                    head = head.left;
                }
            }
        }*/
        if (head != null) {
            Stack<Node> stack = new Stack<>();
           while (!stack.isEmpty() || head!=null){//æ ˆéç©ºæˆ–è€…è¿˜æœ‰éœ€è¦å‹å…¥æ ˆçš„èŠ‚ç‚¹æ—¶éœ€è¦èµ°å¾ªç¯
               if (head!=null){
                   stack.push(head);
                   head=head.left;
               }else{
                   head = stack.pop();
                   System.out.print(head.value+" ");
                   head=head.right;
               }
           }
        }
    }

    /*
     * é€’å½’å®ç°ååºéå†
     * */
    public static void posOrder(Node head) {
        if (head == null) {
            return;
        }
        posOrder(head.left);
        posOrder(head.right);
        System.out.print(head.value + " ");
    }

    /*
     * éé€’å½’å®ç°ååºéå†
     * */
    public static void posOrderUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            stack.push(head);
            Stack<Node> temp = new Stack<>();
            while (!stack.isEmpty()) {
                head = stack.pop();
                temp.push(head);
                if (head.left != null) {
                    stack.push(head.left);
                }
                if (head.right != null) {
                    stack.push(head.right);
                }
            }
            while (!temp.isEmpty()) {
                System.out.print(temp.pop().value + " ");
            }
        }
    }

    /*
    * å®½åº¦ä¼˜å…ˆéå†,ä¹Ÿå°±æ˜¯å±‚åºéå†
    * */
    public static void wOrder(Node head){
        int max=Integer.MIN_VALUE;
        if (head!=null){
            Queue<Node> queue=new LinkedList<>();
            HashMap<Node,Integer> map=new HashMap<>();
            int curLevel=1;
            int curLevelNodes =0;
            map.put(head,1);
            queue.add(head);
            while (!queue.isEmpty()){
                Node cur=queue.poll();
                int curNodeLevel=map.get(cur);
                if (curNodeLevel==curLevel){
                    curLevelNodes++;
                }else{
                    curLevel++;
                    max=Math.max(max, curLevelNodes);
                    curLevelNodes =1;
                }
                System.out.print(cur.value+" ");
                if (cur.left!=null){
                    map.put(cur.left,curNodeLevel+1);
                    queue.add(cur.left);
                }
                if (cur.right!=null){
                    map.put(cur.right,curNodeLevel+1);
                    queue.add(cur.right);
                }
            }
            max=Math.max(max,curLevelNodes);//æœ€åè¦å†æ¯”è¾ƒä¸€æ¬¡ï¼Œå¦åˆ™ä¸ä¼šè€ƒè™‘æœ€åä¸€å±‚çš„å®½åº¦
        }
//        System.out.println(max);
    }
    public static void main(String[] args) {
        Node n4 = new Node(4, null, null);
        Node n5 = new Node(5, null, null);
        Node n6 = new Node(6, null, null);
        Node n7 = new Node(7, null, null);
        Node n2 = new Node(2, n4, n5);
        Node n3 = new Node(3, n6, n7);
        Node head = new Node(1, n2, n3);
        preOrder(head);// 1 2 4 5 3 6 7
        System.out.println("é€’å½’å®ç°å‰åºéå†");
        preOrderUnRecur(head);// 1 2 4 5 3 6 7
        System.out.println("éé€’å½’å®ç°å‰åºéå†");
        inOrder(head);// 4 2 5 1 6 3 7
        System.out.println("é€’å½’å®ç°ä¸­åºéå†");
        inOrderUnRecur(head);// 4 2 5 1 6 3 7
        System.out.println("éé€’å½’å®ç°ä¸­åºéå†");
        posOrder(head);// 4 5 2 6 7 3 1
        System.out.println("é€’å½’å®ç°ååºéå†");
        posOrderUnRecur(head);// 4 5 2 6 7 3 1
        System.out.println("éé€’å½’å®ç°ååºéå†");
        wOrder(head);// 1 2 3 4 5 6 7
        System.out.println("å±‚åºéå†");

    }
}

```

#### æœç´¢æ ‘

* æœç´¢æ ‘ï¼šå·¦å­æ ‘æ¯”è‡ªå·±å°ï¼Œå³å­æ ‘æ¯”è‡ªå·±å¤§ï¼Œæ¯ä¸ªå­æ ‘éƒ½

```java
package Tips;

import java.util.*;

/*
 * åˆ¤æ–­æ˜¯ä¸æ˜¯æœç´¢æ ‘
 * æœç´¢æ ‘ï¼šå·¦å­æ ‘æ¯”è‡ªå·±å°ï¼Œå³å­æ ‘æ¯”è‡ªå·±å¤§ï¼Œæ¯ä¸ªå­æ ‘éƒ½æ»¡è¶³è¯¥ç‰¹æ€§
 * */
public class BST {

/*
     * é‡‡ç”¨morriså®ç°äºŒå‰æ ‘ä¸­åºéå†
     * æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯æœç´¢äºŒå‰æ ‘
     * */
    public static boolean morrisInIsBST(TreeNode head){
        if (head ==null){
            return false;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        int preValue=Integer.MIN_VALUE;
        while (cur!=null){//è¿‡æµç¨‹
            mostRight=cur.left;//æ‰¾curå·¦å­æ ‘ä¸Šçš„æœ€å³èŠ‚ç‚¹ï¼Œä»å·¦å­æ ‘å¤´èŠ‚ç‚¹å¼€å§‹å¯»æ‰¾mostRight
            if (mostRight!=null){//æœ‰å·¦å­æ ‘
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//è¿™æ˜¯ç¬¬ä¸€æ¬¡æ¥åˆ°cur
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//ä¹‹å‰æ¥è¿‡cur,æ¥ä¸‹æ¥è¦ç§»åˆ°cur.right
                }
            }
            if (cur.val<=preValue){
                return false;
            }
            preValue=cur.val;
            cur=cur.right;//curæ²¡æœ‰å·¦å­æ ‘æˆ–è€…å·²ç»èµ°å®Œå·¦å­æ ‘
        }
        return true;
    }
    /*
     * äºŒå‰æ ‘èŠ‚ç‚¹
     * */
    public static class Node {
        Integer value;
        Node left;
        Node right;

        public Node(Integer value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    /*
    * æ–¹æ³•ä¸€ï¼š æå¤æ‚äº†ï¼Œæ²¡æœ‰é‚£ä¹ˆå¤æ‚
    *  éå† ä¸­åºéå†åçš„é˜Ÿåˆ—
    * åˆ¤æ–­æ˜¯å¦æ»¡è¶³æœç´¢æ ‘çš„æ¡ä»¶
    * */
    public static boolean isBST(Node head) {
        Queue<Integer> queue = process1(head);
        if (queue!=null){
            int s = queue.poll();
            while (!queue.isEmpty()) {
                int m = queue.poll();
                if (s >= m) {
                    return false;
                }
                s=m;
            }
        }
        return true;
    }
    /*
    * é€’å½’å®ç°ä¸­åºéå†1
    * å°†é“¾è¡¨ä¸­åºéå†æ”¾åˆ°é˜Ÿåˆ—ä¸­è¿”å›
    * */
    private static Queue<Integer> process1(Node head) {
        if (head == null) {
            return null;
        }
        Queue<Integer> left = process1(head.left);
        if (left != null) {
            left.add(head.value);
            Queue<Integer> right = process1(head.right);
            while (right != null && !right.isEmpty()) {
                left.add(right.poll());
            }
            return left;
        } else {
            Queue<Integer> cur = new LinkedList<>();
            cur.add(head.value);
            Queue<Integer> right = process1(head.right);
            while (right != null && !right.isEmpty()) {
                left.add(right.poll());
            }
            return cur;
        }
    }

    /*
     * æ–¹æ³•äºŒï¼šæ¨èï¼
     * é€’å½’å®ç°ä¸­åºéå†2
     * */
    public static Integer preValue =Integer.MIN_VALUE;
    private static boolean isBST2(Node head) {
        if (head == null) {
            return true;
        }
        boolean left= isBST2(head.left);
        if (!left){
            return false;
        }
        if (head.value<= preValue){
            return false;
        }else{
            preValue =head.value;
        }
        return isBST2(head.right);
    }

    /*
    * æ–¹æ³•ä¸‰ï¼šæœ€ç®€å•
    * ä¸­åºéå†æ”¾é›†åˆ
    * */
    public static boolean isBST3(Node head){
        if (head==null){
            return false;
        }
        List<Node> list=new ArrayList<>();
        process3(head,list);
        Node preNode = list.remove(0);
        for (Node cur : list) {
            if (preNode.value>=cur.value){
                return false;
            }
            preNode=cur;
        }
        return true;
    }
    private static void process3(Node head,List<Node> list){
        if (head == null) {
            return;
        }
       process3(head.left,list);
        list.add(head);
        process3(head.right,list);
    }

    /*
     * é€’å½’åˆ¤æ–­æ˜¯ä¸æ˜¯æœç´¢æ ‘
     * */
    private static class Result{
        int max;
        int min;
        boolean isBST;

        public Result(int max, int min, boolean isBST) {
            this.max = max;
            this.min = min;
            this.isBST = isBST;
        }
    }
    public static Result isBstRecur(Node head){
        if (head==null){
            return new Result(Integer.MIN_VALUE,Integer.MAX_VALUE,true);
        }
        Result leftResul = isBstRecur(head.left);
        Result rightResult = isBstRecur(head.right);
        int max=Math.max(head.value,Math.max(leftResul.max, rightResult.max));
        int min=Math.min(head.value,Math.min(leftResul.min,rightResult.min));
        boolean isBST= leftResul.isBST && rightResult.isBST && (head.value>leftResul.max)&&(head.value< rightResult.min);
        return new Result(max,min,isBST);
    }

    /*
     * åˆ©ç”¨éé€’å½’å®ç°ä¸­åºéå†
     * æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯æœç´¢æ ‘
     * */
    public static boolean isBstUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            Integer preValue =Integer.MIN_VALUE;
            while (!stack.isEmpty() || head!=null){//æ ˆéç©ºæˆ–è€…è¿˜æœ‰éœ€è¦å‹å…¥æ ˆçš„èŠ‚ç‚¹æ—¶éœ€è¦èµ°å¾ªç¯
                if (head!=null){
                    stack.push(head);
                    head=head.left;
                }else{
                    head = stack.pop();
                    if (head.value<= preValue){
                        return false;
                    }
                    preValue =head.value;
//                    System.out.print(head.value+" ");//ä¸­åºéå†
                    head=head.right;
                }
            }
        }
        return true;
    }
    public static void main(String[] args) {
        Node n8 = new Node(1, null, null);
        Node n4 = new Node(2, n8, null);
        Node n5 = new Node(4, null, null);
        Node n6 = new Node(61, null, null);
        Node n7 = new Node(8, null, null);
        Node n2 = new Node(3, n4, n5);
        Node n3 = new Node(7, n6, n7);
        Node head = new Node(5, n2, n3);
        System.out.println(isBST(head));
        System.out.println(isBST2(head));
        System.out.println(isBST3(head));
        System.out.println(isBstUnRecur(head));
        System.out.println(isBstRecur(head).isBST);
    }
}

```



#### å®Œå…¨äºŒå‰æ ‘

```java
package Tips;
import dataStructure.TreeNode;

import javax.swing.tree.DefaultMutableTreeNode;
import java.util.LinkedList;
import java.util.Queue;

/*
* åˆ¤æ–­ä¸€ä¸ªäºŒå‰æ ‘æ˜¯ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘
* */
public class CompleteBinaryTree {


    public static boolean isW(TreeNode head){
        if (head==null){
            return false;
        }
        Queue<TreeNode> queue=new LinkedList<>();
        /*
        * æ ‡è®°ï¼šæ˜¯å¦é‡åˆ°è¿‡ç¬¬ä¸€ä¸ªå·¦å³å­ä¸å…¨çš„èŠ‚ç‚¹,ç¬¬ä¸€æ¬¡é‡åˆ°æ—¶æ ‡è®°ä¸ºtrueï¼Œ
        * åé¢é‡åˆ°å¶èŠ‚ç‚¹ä¹Ÿä¼šæ ‡è®°ä¸ºtrueä½†æ˜¯ä¸å½±å“åˆ¤æ–­,å› ä¸ºä¸æ”¹å˜flagçš„å€¼
        * */
        boolean flag=false;
        queue.add(head);
        while (!queue.isEmpty()){
            head= queue.poll();
            /*
            * åˆ¤æ–­æ˜¯å¦æ»¡è¶³å®Œå…¨äºŒå‰æ ‘çš„ç‰¹æ€§
            * 1. å­˜åœ¨å³å­æ ‘å´æ²¡æœ‰å·¦å­æ ‘ä¸æ˜¯äºŒå‰æ ‘
            * 2. å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå·¦å³å­ä¸å…¨ï¼Œåˆ™åç»­çš†æ˜¯å¶èŠ‚ç‚¹-->å·²ç»é‡åˆ°è¿‡ç¬¬ä¸€ä¸ªå·¦å³å­ä¸å…¨çš„èŠ‚ç‚¹ï¼Œ
            *    ä½†æ˜¯è¿˜é‡åˆ°ä¸æ˜¯å¶èŠ‚ç‚¹çš„èŠ‚ç‚¹flag &&(head.right!=null || head.left!=nullï¼‰
            * */
            if ((head.right!=null && head.left==null)||(flag &&(head.right!=null || head.left!=null))){
                return false;
            }
            if (head.left == null || head.right == null){
                flag=true;
            }
            if (head.left!=null){
                queue.add(head.left);
            }
            if (head.right!=null){
                queue.add(head.right);
            }
        }
        return true;
    }

    public static void main(String[] args) {
        TreeNode n8= new TreeNode(8, null, null);
        TreeNode n4 = new TreeNode(4, n8, null);
        TreeNode n5 = new TreeNode(5, null, null);
        TreeNode n6 = new TreeNode(6, null, null);
        TreeNode n7 = new TreeNode(7, null, null);
        TreeNode n2 = new TreeNode(2, n4, n5);
        TreeNode n3 = new TreeNode(3, n6, n7);
        TreeNode head = new TreeNode(1, n2, n3);
        System.out.println(isW(head));
    }
}

```

```java
// æ ‘èŠ‚ç‚¹

public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return String.valueOf(this.val);
    }
}


```

#### å¹³è¡¡äºŒå‰æ ‘

```java
package Tips;
import dataStructure.TreeNode;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

/*
* å¹³è¡¡äºŒå‰æ ‘
* å·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸ä¼šè¶…è¿‡1(é«˜åº¦å·®å°äº2)
* */
public class BalancedBinaryTree {
    private static class Result{
        boolean isBalanced;
        int height;

        public Result(boolean isBalanced, int height) {
            this.isBalanced = isBalanced;
            this.height = height;
        }
    }
    public static boolean isBalancedBinaryTree(TreeNode head){
        if (head==null){
            return false;
        }
        return process(head).isBalanced;
    }
    private static Result process(TreeNode head){
        if (head==null){
            return new Result(true,0);
        }
        Result leftResult = process(head.left);
        Result rightResult = process(head.right);
        int height=Math.max(leftResult.height,rightResult.height)+1;//é«˜åº¦å°±æ˜¯å·¦å³å­èŠ‚ç‚¹ä¸­é«˜ä¸€ç‚¹çš„èŠ‚ç‚¹çš„é«˜åº¦åŠ ä¸€ï¼ï¼ï¼
        boolean isBalanced=leftResult.isBalanced&&rightResult.isBalanced&&(Math.abs(leftResult.height-rightResult.height)<2);
        return new Result(isBalanced,height);
 }
   }
```

#### æ»¡äºŒå‰æ ‘

```java
package Tips;


import dataStructure.TreeNode;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

/*
* åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡äºŒå‰æ ‘
* æœ€å¤§çš„æ·±åº¦Lå’ŒèŠ‚ç‚¹æ•°N
* æ»¡è¶³ï¼šN=2^L-1
* */
public class FullBinaryTree {
    /*
    * éé€’å½’æ–¹å¼åˆ¤æ–­
    * è‡ªå·±å†™çš„åº”è¯¥æ²¡æœ‰é—®é¢˜çš„
    * */
    public static boolean isFullBinaryTreeUnRecur(TreeNode head){
        if (head==null){
            return false;
        }
        Queue<TreeNode> queue=new LinkedList<>();
        HashMap<TreeNode,Integer> levelMap=new HashMap<>();
        int L =1;
        int N =0;
        queue.add(head);
        levelMap.put(head,1);
        while (!queue.isEmpty()){
            TreeNode curNode = queue.poll();
            Integer curNodeLevel = levelMap.get(curNode);
            L=curNodeLevel;
            N++;
            if (curNode.left!=null){
                levelMap.put(curNode.left,curNodeLevel+1);
                queue.add(curNode.left);
            }
            if (curNode.right!=null){
                levelMap.put(curNode.right,curNodeLevel+1);
                queue.add(curNode.right);
            }
        }

        return N==(1<<L) -1;
    }

    private static class Result{
        int height;
        int nodes;

        public Result(int level, int nodes) {
            this.height = level;
            this.nodes = nodes;
        }
    }
    public static boolean isFullBinaryTreeRecur(TreeNode head){
        if (head==null){
            return false;
        }
        Result result = isFullBinaryTree(head);
//        return result.nodes==(Math.pow(2,result.height) -1);
        return result.nodes==(1<< result.height) -1;//ä½è¿ç®—è¿™é‡Œå¯èƒ½æœ‰é—®é¢˜ã€‚ã€‚æ˜¯è¿™ä¹ˆå†™çš„å§ï¼Œæ˜¯æ˜¯

    }
    public static Result isFullBinaryTree(TreeNode head){
        if (head==null){
            return new Result(0,0);
        }
        Result leftResult = isFullBinaryTree(head.left);
        Result rightResult = isFullBinaryTree(head.right);
        int level=Math.max(leftResult.height,rightResult.height)+1;
        int nodes=leftResult.nodes+ rightResult.nodes+1;
        return new Result(level,nodes);
    }

    public static void main(String[] args) {
        TreeNode n9=new TreeNode(9,null,null);
        TreeNode n8= new TreeNode(8, n9, null);
        TreeNode n4 = new TreeNode(4, null, n8);
        TreeNode n5 = new TreeNode(5, null, null);
        TreeNode n6 = new TreeNode(6, null, null);
        TreeNode n7 = new TreeNode(7, null, null);
        TreeNode n2 = new TreeNode(2, n4, n5);
        TreeNode n3 = new TreeNode(3, n6, n7);
        TreeNode head = new TreeNode(1, n2, n3);
        System.out.println(isFullBinaryTreeRecur(head));
        System.out.println(isFullBinaryTreeUnRecur(head));
    }


}

```

#### AVLæ ‘ï¼ˆå·¦æ ‘å’Œå³æ ‘å¤§å°ä¸è¶…è¿‡1ï¼‰

1. å½“æ’å…¥æˆ–åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå¯èƒ½ä¼šè®©æ•´æ£µAVLæ ‘ä¸å¹³è¡¡ã€‚æ­¤æ—¶ï¼Œåªéœ€è¦æŠŠæœ€å°ä¸å¹³è¡¡å­æ ‘è°ƒæ•´å³å¯æ¢å¤æ•´ä½“çš„å¹³è¡¡æ€§ã€‚

2. æ ‘çš„LL,RR,LR,RLè°ƒæ•´ã€‚

3. æ’å…¥å’Œåˆ é™¤æ—¶çš„è°ƒæ•´ç»†èŠ‚ã€‚
   
   
   
   

#### SBæ ‘

1. æ¯æ£µæ ‘çš„å¤§å°ï¼Œä¸å°äºå…¶å…„å¼Ÿçš„å­æ ‘å¤§å°ã€‚

2. å³æ²¡æ£µå”å”æ ‘çš„å¤§å°ï¼Œä¸å°äºå…¶ä»»ä½•ä¾„å­æ ‘çš„å¤§å°
   
   

#### æœ€ä½å…¬å…±ç¥–å…ˆèŠ‚ç‚¹

```java
package Tips;

import dataStructure.TreeNode;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/*
* ç»™å®šä¸€æ£µæ ‘ä¸Šçš„ä¸¤ä¸ªæ ‘èŠ‚ç‚¹
* æ‰¾å‡ºæœ€ä½çš„å…¬å…±ç¥–å…ˆèŠ‚ç‚¹
* */
public class FindFirstFatherNode {
    /*
     * æœ€ä½³æ–¹æ¡ˆï¼ï¼ï¼
     * */
    public static TreeNode bestSolution(TreeNode head,TreeNode n1,TreeNode n2){
        if (head==null || head==n1 || head==n2){
            return head;
        }
        TreeNode left = bestSolution(head.left, n1, n2);
        TreeNode right = bestSolution(head.right, n1, n2);
        //å·¦å³ä¸¤æ£µæ ‘éƒ½æœ‰è¿”å›å€¼ï¼Œå°±æ˜¯æ±‡èš
        if (left!=null && right!=null){
            return head;
        }
        //ä¸æ˜¯éƒ½æœ‰è¿”å›å€¼ï¼Œè¿”å›æœ‰å€¼çš„é‚£ä¸ªï¼Œä¹Ÿæœ‰å¯èƒ½éƒ½æ²¡æœ‰å€¼
        return left!=null?left:right;
    }

    /*
    * æŠŠä¸€ä¸ªèŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹ç»è¿‡çš„èŠ‚ç‚¹éƒ½æ”¾åˆ°ä¸€ä¸ªseté›†åˆä¸­
    * ç„¶åè®©å¦ä¸€ä¸ªèŠ‚ç‚¹å¾€ä¸Šçªœï¼Œå¦‚æœå¾€ä¸Šçªœçš„è¿‡ç¨‹ä¸­ä¸seté›†åˆä¸­çš„èŠ‚ç‚¹ç›¸é‡
    * é‚£ä¹ˆè¯¥èŠ‚ç‚¹å°±æ˜¯æœ€ä½çš„å…¬å…±ç¥–å…ˆèŠ‚ç‚¹
    * */
    public static TreeNode findFFNode(TreeNode head,TreeNode n1,TreeNode n2){
        if (head==null){
            return null;
        }
        HashMap<TreeNode,TreeNode> fatherMap=new HashMap<>();
        fatherMap.put(head,head);
        getFatherNode(head,fatherMap);
        Set<TreeNode> set1=new HashSet<>();
        TreeNode cur=n1;
        while (fatherMap.get(cur)!=cur){
            set1.add(cur);
            cur=fatherMap.get(cur);
        }
        set1.add(head);
        while (fatherMap.get(n2)!=n2){
            if (set1.contains(n2)){
                return n2;
            }
            n2=fatherMap.get(n2);
        }
        return head;
    }
    /*
    * éå†æ•´æ£µæ ‘è·å–æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å¹¶æ”¾åˆ°HashMapä¸­
    * HashMap<å­èŠ‚ç‚¹,çˆ¶èŠ‚ç‚¹>
    * */
    private static void getFatherNode(TreeNode head, HashMap<TreeNode,TreeNode> fatherMap){
       if (head==null){
           return;
       }
        fatherMap.put(head.left,head);
        fatherMap.put(head.right,head);
       getFatherNode(head.left,fatherMap);
       getFatherNode(head.right,fatherMap);
    }
    public static void main(String[] args) {
        TreeNode n9=new TreeNode(9,null,null);
        TreeNode n8= new TreeNode(8, n9, null);
        TreeNode n4 = new TreeNode(4, null, n8);
        TreeNode n5 = new TreeNode(5, null, null);
        TreeNode n6 = new TreeNode(6, null, null);
        TreeNode n7 = new TreeNode(7, null, null);
        TreeNode n2 = new TreeNode(2, n4, n5);
        TreeNode n3 = new TreeNode(3, n6, n7);
        TreeNode head = new TreeNode(1, n2, n3);
        System.out.println(findFFNode(head, n5, n9).val);
        System.out.println(bestSolution(head, n5, n8).val);
    }
}

```

#### åç»§èŠ‚ç‚¹

```java
package Tips;
/*
 * æ‰¾åˆ°æŸä¸€ä¸ªæ ‘èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹
 * åç»§èŠ‚ç‚¹å°±æ˜¯ä¸­åºéå†è¿‡ç¨‹ä¸­çš„åä¸€ä¸ªèŠ‚ç‚¹
 * */
public class GetSuccessorNode {
    /*
    * å¸¦æœ‰çˆ¶èŠ‚ç‚¹çš„æ ‘èŠ‚ç‚¹
    * */
    private static class Node {
        int value;
        Node parent;
        Node left;
        Node right;

        public Node(int value, Node parent, Node left, Node right) {
            this.value = value;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }
    }
    /*
    * æ‰¾åˆ°åç»§èŠ‚ç‚¹
    * */
    public static Node getSuccessorNode(Node node) {
        if (node == null) {
            return null;
        }
        if (node.right != null) {//å¦‚æœæŸèŠ‚ç‚¹å­˜åœ¨å³å­æ ‘ï¼Œé‚£ä¹ˆåç»§èŠ‚ç‚¹å°±æ˜¯å³å­æ ‘ä¸Šæœ€å·¦ä¾§çš„èŠ‚ç‚¹
            return mostLeftNode(node.right);
        }else{
            Node parent = node.parent;
            while (parent!=null && node!=parent.left){//å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œé‚£ä¹ˆåç»§èŠ‚ç‚¹å°±æ˜¯çˆ¶èŠ‚ç‚¹ï¼Œå¦åˆ™éœ€è¦å‘ä¸Šçªœ
                //çªœåˆ°é¡¶äº†è¯´æ˜è¯¥èŠ‚ç‚¹æ˜¯æ•´æ£µæ ‘ä¸Šæœ€å³ä¾§çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆåç»§èŠ‚ç‚¹å°±æ˜¯null
                node=parent;
                parent=node.parent;
            }
            return parent;
        }
    }

    /*
     * æ‰¾åˆ°æŸæ ‘ä¸Šæœ€å·¦çš„èŠ‚ç‚¹
     * */
    private static Node mostLeftNode(Node node) {
        if (node == null) {
            return null;
        }
        Node leftNode = mostLeftNode(node.left);
        return leftNode != null ? leftNode : node;

    }
}

```

#### æŠ˜çº¸

```java
package Tips;
/*
* å°†ä¸€ä¸ªçº¸æ¡å¯¹æŠ˜Næ¬¡
* ä»ä¸Šåˆ°ä¸‹æ‰“å°æŠ˜ç—•çš„æ–¹å‘,æ‰“å°ç»“æœæ»¡è¶³ä¸‹é¢çš„äºŒå‰æ ‘ä¸­åºéå†æ‰“å°
*               å‡¹          äºŒå‰æ ‘ç‰¹ç‚¹ï¼šå¤´å‡¹ï¼Œå…¶ä½™æ ‘èŠ‚ç‚¹å·¦å­©å­ä¸ºå‡¹ï¼Œå³å­©å­ä¸ºå‡¸ï¼ŒæŠ˜å æ¬¡æ•°Nç­‰äºæ ‘çš„é«˜åº¦
*             /    \
*           å‡¹      å‡¸
*          /  \    /  \
*        å‡¹    å‡¸  å‡¹  å‡¸   
* */
public class Exercise {

    /*
    * iä¸ºèŠ‚ç‚¹çš„å±‚æ•°
    * Nä¸ºä¸€å…±çš„å±‚æ•°
    * down==true å‡¹
    * down==false å‡¸
    * */
    public static void print(int N){
        p(N,1,true);
    }
    public static void p(int N,int i,boolean down){
        if (i>N){
            return;
        }
        p(N,i+1,true);
        System.out.print(down ?"å‡¹":"å‡¸");
        p(N,i+1,false);
    }
    public static void main(String[] args) {
        print(3);
    }
}


```
