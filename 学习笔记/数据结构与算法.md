## 队列 Queue

一种以顺序的方式维护的一组数据，一端（头）添加数据，从另一端（尾）移除数据。

## 堆

### 大根堆

1.大根堆有着如下特点：
       a.顺序：堆顶元素永远是最大的。
       b.形状：堆是一颗完全二叉树。

 这两个特性保证了堆在插入和删除的过程中最大时间复杂度也是满足O(logn)的，所以是一种非常高效的数据结构格式。

2.更新堆的两种方式，分别对应了插入元素和删除堆顶元素操作：
         自底向上 
         自顶向下

3.实现 可以使用数组作为隐式树（因为结构是完全二叉树）
         如果当前元素的下标为i，那么：
        当前元素的父亲下标：i - 1 / 2 
        当前元素的左子节点下标：i * 2 + 1
        当前元素的右子节点下标：i * 2 + 2 
        小根堆同理

### 小根堆

## 栈

## 排序算法

   排序算法                 时间复杂度        空间复杂度      稳定性  

* 1.选择排序          O(N^2)                O(1)                  X 
* 2.冒泡排序          O(N^2)                O(1)                 ✔  
* 3.插入排序          O(N^2)                O(1)                 ✔  
* 4.归并排序          O(N*logN)          O(N)                ✔  
* 5.快速排序3.0     O(N*logN)          O(logN)          X  
* 6.堆排序               O(N*logN)          O(1)                X 

## 图

### 图结构

```java
package graph;

import java.util.HashMap;
import java.util.HashSet;
/*
* 图结构
* */
public class Graph {
    public HashMap<Integer, Node> nodes;//点集
    public HashSet<Edge> edges;//边集

    public Graph() {
        this.nodes=new HashMap<>();
        this.edges=new HashSet<>();
    }

    public Graph(HashMap<Integer, Node> nodes, HashSet<Edge> edges) {
        this.nodes = nodes;
        this.edges = edges;
    }

}

```

```java
package graph;

import java.util.ArrayList;

/*
* 图节点
* */
public class Node {
    public int value;
    public int in;//入度：入节点个数
    public int out;//出度：出节点个数
    public ArrayList<Node> next;
    public ArrayList<Edge> edges;

    public Node() {
        this.next=new ArrayList<>();
        this.edges=new ArrayList<>();
    }

    public Node(int value) {
        this.next=new ArrayList<>();
        this.edges=new ArrayList<>();
        this.value = value;
    }

    public Node(int value, int in, int out, ArrayList<Node> next, ArrayList<Edge> edges) {
        this.value = value;
        this.in = in;
        this.out = out;
        this.next = next;
        this.edges = edges;
    }
}

```

```java
package graph;

/*
* 图的边
* */
public class Edge {
    public int weight;//权重或者长度
    public Node from;
    public Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}

```

### 图生成器

```java
package graph;
/*
* 图生成器
* 也就是把用户给出的图结构以自己熟悉的图方式表现出来
* */
public class GraphGenerator {

    /*
    * matrix矩阵
    * N*3
    * 第一列代表from节点的值 第二列代表to节点的值 第三列代表边的权重
    * */
    public static Graph createGraph(int[][] matrix){
        Graph graph=new Graph();
        for (int i = 0; i < matrix.length; i++) {
            int from = matrix[i][0];
            int to = matrix[i][1];
            int weight = matrix[i][2];
            if (!graph.nodes.containsKey(from)){
                graph.nodes.put(from,new Node(from));
            }
            if (!graph.nodes.containsKey(to)){
                graph.nodes.put(to,new Node(to));
            }
            Node fromNode = graph.nodes.get(from);
            Node toNode = graph.nodes.get(to);
            Edge edge=new Edge(weight,fromNode,toNode);
            fromNode.out++;
            fromNode.next.add(toNode);
            fromNode.edges.add(edge);
            toNode.in++;
            graph.edges.add(edge);
        }
        return graph;
    }
}


```

```java
package graph;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/*
* 图的宽度优先遍历
* */
public class BSF {

    /*
    * 从node出发，进行图的宽度优先遍历
    * */
    public static void bsf(Node node){
        if (node==null){
            return;
        }
        Queue<Node> queue=new LinkedList<>();
        //用set是为了防止有环图进入死循环
        HashSet<Node> set=new HashSet<>();
        queue.add(node);
        set.add(node);
        while (!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur.value);
            for (Node next : cur.next) {
                if (!set.contains(next)){
                    set.add(next);
                    queue.add(next);
                }
            }
        }
    }
}

```

### 宽度优先遍历

```java
package graph;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/*
* 图的宽度优先遍历
* */
public class BSF {

    /*
    * 从node出发，进行图的宽度优先遍历
    * */
    public static void bsf(Node node){
        if (node==null){
            return;
        }
        Queue<Node> queue=new LinkedList<>();
        //用set是为了防止有环图进入死循环
        HashSet<Node> set=new HashSet<>();
        queue.add(node);
        set.add(node);
        while (!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur.value);
            for (Node next : cur.next) {
                if (!set.contains(next)){
                    set.add(next);
                    queue.add(next);
                }
            }
        }
    }
}

```

### 拓扑排序

```java
package graph;

import java.util.*;

/*
* 拓扑排序
* */
public class SortedTopology {

    //有向无环图
    public static ArrayList<Node> sortedTopology(Graph graph){
        if (graph ==null){
            return null;
        }
        //收集入度为0的节点
        Queue<Node> queue=new LinkedList<>();
        //记录所有节点的入度
        HashMap<Node,Integer> map=new HashMap<>();
        //保存结果并返回
        ArrayList<Node> list=new ArrayList<>();
        for (Node node : graph.nodes.values()) {
            if (node.in==0){
                queue.add(node);
            }
            map.put(node,node.in);
        }
        while (!queue.isEmpty()){
            Node cur = queue.poll();
            list.add(cur);
            for (Node next:cur.next){
                map.put(next,map.get(next)-1);
                if (map.get(next)==0){
                    queue.add(next);
                }
            }
        }
        return list;
    }

    public static void main(String[] args) {
        Graph graph = new Graph();
        Node A=new Node(1);
        A.in=0;
        A.out=2;
        Node B=new Node(2);
        B.in=1;
        B.out=2;
        Node C=new Node(3);
        C.in=2;
        C.out=1;
        A.next.add(B);
        A.next.add(C);
        B.next.add(C);
        Node D=new Node(4);
        D.in=2;
        D.out=0;
        B.next.add(D);
        C.next.add(D);
        Edge e1 = new Edge(1, A, C);
        Edge e2 = new Edge(1, A, B);
        Edge e3 = new Edge(1, B, D);
        Edge e4 = new Edge(1, B, C);
        Edge e5 = new Edge(1, C, D);
        A.edges.add(e1);
        A.edges.add(e2);
        B.edges.add(e3);
        B.edges.add(e4);
        C.edges.add(e5);
        graph.nodes.put(1,A);
        graph.nodes.put(2,B);
        graph.nodes.put(3,C);
        graph.nodes.put(4,D);
        graph.edges.add(e1);
        graph.edges.add(e2);
        graph.edges.add(e3);
        graph.edges.add(e4);
        graph.edges.add(e5);
        for (Node x : sortedTopology(graph)) {
            System.out.print(x.value+" ");
        }
        System.out.println();
    }
}

```

### 最小生成树

```java
package graph;

import java.util.*;

/*
 * 找出图中的最小生成树
 * 最小生成树 MinimumSpanningTree
 * */
public class MST {
    public static HashMap<Node, List<Node>> listMap = new HashMap<>();

    //生成每个节点所在的集合表
    public static void getSetMap(Graph graph) {
        if (graph == null) {
            return;
        }
        for (Node cur : graph.nodes.values()) {
            List<Node> set = new ArrayList<>();
            set.add(cur);
            listMap.put(cur, set);
        }
    }

    //判断两个节点所在的集合是否相同
    public static boolean isSameSet(Node from, Node to) {
        List<Node> fromList = listMap.get(from);
        List<Node> toList = listMap.get(to);
        return fromList == toList;
    }

    //合并两个节点的集合
    public static void union(Node from, Node to) {
        List<Node> fromList = listMap.get(from);
        List<Node> toList = listMap.get(to);
        for (Node node : fromList) {
            toList.add(node);
            listMap.put(node, toList);
        }
    }

    //定义一个边比较器
    public static class EdgeComparator implements Comparator<Edge> {
        @Override
        public int compare(Edge o1, Edge o2) {
            return o1.weight - o2.weight;
        }
    }

    /*
     * k算法寻找最小生成树
     * */
    public static Set<Edge> kruskalMST(Graph graph) {
        Set<Edge> result = new HashSet<>();
        getSetMap(graph);
        PriorityQueue<Edge> queue = new PriorityQueue<>(new EdgeComparator());
        queue.addAll(graph.edges);
        while (!queue.isEmpty()) {
            Edge cur = queue.poll();
            if (!isSameSet(cur.from, cur.to)) {
                result.add(cur);
                union(cur.from, cur.to);
            }
        }
        return result;
    }
    /*
     * p算法寻找最小生成树
     * */
    public static Set<Edge> primMST(Graph graph) {
        Set<Edge> result = new HashSet<>();
        //标记过的边放入队列按照从小到大的顺序排列
        PriorityQueue<Edge> queue = new PriorityQueue<>(new EdgeComparator());
        //判断节点是否被考察过,考察过的放入集合中
        Set<Node> isCheck = new HashSet<>();
        for (Node node : graph.nodes.values()) {//为了处理整个图不连通的问题，森林
            //从一个没有被考察过的节点开始
            if (!isCheck.contains(node)){
                //把当前节点标记为已考察
                isCheck.add(node);
                //把该节点的所有边放入标记队列
                queue.addAll(node.edges);
                while (!queue.isEmpty()){
                    Edge poll = queue.poll();
                    if (!isCheck.contains(poll.to)){
                        result.add(poll);
                        isCheck.add(poll.to);
                        queue.addAll(poll.to.edges);
                    }
                }
            }
        }
        return result;
    }

    /*
     * 我自己写的p算法代码，有待考验
     * */
    public static Set<Edge> primMST2(Graph graph) {
        Set<Edge> result = new HashSet<>();
        //标记过的边放入队列按照从小到大的顺序排列
        PriorityQueue<Edge> queue = new PriorityQueue<>(new EdgeComparator());
        //判断节点是否被考察过,考察过的放入集合中
        Set<Node> isCheck = new HashSet<>();
        //判断边是否已经标记过
        HashMap<Edge, Boolean> isMark = new HashMap<>();
        //一开始所有的边都是没有标记过的
        for (Edge edge : graph.edges) {
            isMark.put(edge, false);
        }
        Stack<Node> stack=new Stack<>();
        for (Node value : graph.nodes.values()) {
            stack.push(value);//选择任意一个节点开始，，怎么选呢？
            //选择图中的任意节点开始寻找最小生成树
            while (!stack.isEmpty()) {
                ArrayList<Edge> edges = stack.pop().edges;
                //标记所有没有标记过的边放入队列
                for (Edge edge : edges) {
                    if (!isMark.get(edge)){
                        isMark.put(edge,true);
                        queue.add(edge);
                    }
                }
                //取出标记过的边中的最小
                Edge poll = queue.poll();
                while (!queue.isEmpty()){
                    if (!isCheck.contains(poll.to) ||!isCheck.contains(poll.from)){
                        result.add(poll);
                        isCheck.add(poll.to);
                        isCheck.add(poll.from);
                        stack.push(!isCheck.contains(poll.to)?poll.to:poll.from);
                    }else{
                        poll=queue.poll();
                    }
                }
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Graph graph = new Graph();
        Node A=new Node(1);
        A.in=0;
        A.out=2;
        Node B=new Node(2);
        B.in=1;
        B.out=2;
        Node C=new Node(3);
        C.in=2;
        C.out=1;
        A.next.add(B);
        A.next.add(C);
        B.next.add(C);
        Node D=new Node(4);
        D.in=2;
        D.out=0;
        B.next.add(D);
        C.next.add(D);
        Edge e1 = new Edge(1, A, C);
        Edge e2 = new Edge(1, A, B);
        Edge e3 = new Edge(1, B, D);
        Edge e4 = new Edge(1, B, C);
        Edge e5 = new Edge(1, C, D);
        A.edges.add(e1);
        A.edges.add(e2);
        B.edges.add(e3);
        B.edges.add(e4);
        C.edges.add(e5);
        graph.nodes.put(1,A);
        graph.nodes.put(2,B);
        graph.nodes.put(3,C);
        graph.nodes.put(4,D);
        graph.edges.add(e1);
        graph.edges.add(e2);
        graph.edges.add(e3);
        graph.edges.add(e4);
        graph.edges.add(e5);
        Set<Edge> edges = primMST2(graph);
        for (Edge edge : edges) {
            System.out.println(edge.weight);
        }
        System.out.println("=======");
        Set<Edge> edges2 = primMST(graph);
        for (Edge edge : edges2) {
            System.out.println(edge.weight);
        }
    }

}

```

### 迪杰斯特拉算法

解法 一

```java
package graph;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
/*
* 迪杰斯特拉算法
* 用一个HashMap记录到每个节点的距离
* 用一个HashSet集合记录锁定(不在更新到该节点的距离，已经找到 到该节点的最短距离)的节点
* */
public class Dijkstral {
    public static HashMap<Node,Integer> dijkstral(Node head){
        //记录从指定节点到所有节点的最短距离
        HashMap<Node,Integer> distanceMap=new HashMap<>();
        //如果找到到某节点的最短距离，那么锁住该节点和对应距离
        Set<Node> selected=new HashSet<>();
        //开始节点到自己的距离为零，并且目前没有被锁定
        distanceMap.put(head,0);
        //首先找到到指定节点距离最短的并且没有被锁定的节点
        Node minNode=getMinDistanceAndUnSelectedNode(distanceMap,selected);//这里得到的minNode就是指定节点自己
        while (minNode!=null){
            int minNodeDistance= distanceMap.get(minNode);
            for (Edge edge : minNode.edges) {
                Node toNode=minNode!=edge.to?edge.to:minNode;//无向图，能确保edge.to是这个边上的另一端的节点吗？有点疑问
//                TrieNode toNode=minNode!=edge.to; //为了安全起见还是判断以下
                if (!distanceMap.containsKey(toNode)){
                    distanceMap.put(toNode,minNodeDistance+edge.weight);
                }else {
                    distanceMap.put(toNode,Math.min(distanceMap.get(toNode),minNodeDistance+edge.weight));
                }
            }
            selected.add(minNode);
            minNode=getMinDistanceAndUnSelectedNode(distanceMap,selected);
        }
        return distanceMap;
    }

    private static Node getMinDistanceAndUnSelectedNode(HashMap<Node, Integer> distanceMap, Set<Node> selected) {
        int minDistance=Integer.MAX_VALUE;
        Node minNode=null;
        for (Node node : distanceMap.keySet()) {
            if (distanceMap.get(node)<minDistance && !selected.contains(node)){
                minNode=node;
                minDistance=distanceMap.get(node);
            }
        }
        return minNode;
    }
}

```

解法二

```java
package heap;
import graph.Edge;
import graph.Node;
import java.util.HashMap;
/*
* 用自定义的小根堆实现迪杰斯特拉算法
* 向小根堆中加入某节点和到该节点的新距离之后
* 小根堆会根据传入的新距离判断是否要更新距离，
* 并且加入一个新节点会自动进行热排序，一直保持小根堆，
* pop的节点都是距离最小的节点，加入结果集中返回
*
* */
public class Dijkstral {
    public static HashMap<Node,Integer> dijkstral(Node head,int size){
        HashMap<Node,Integer> resultMap=new HashMap<>();
        NodeHeap nodeHeap = new NodeHeap(size);
        nodeHeap.addOrUpdateOrIgnore(head,0);
        while (!nodeHeap.isEmpty()) {
            NodeHeap.NodeRecord pop = nodeHeap.pop();
            Node cur= pop.node;
            int distance= pop.distance;
            for (Edge edge : cur.edges) {
                //将到当前节点的距离distance加上邻边的权重weight作为到to节点的新距离传入小根堆，小根堆会判断是否要更新成传入的距离，会做判断
                nodeHeap.addOrUpdateOrIgnore(edge.to,distance+ edge.weight);
            }
            resultMap.put(cur,distance);
        }
        return resultMap;
    }
    public static class NodeHeap{
        /*
         * distance操作
         * 1. 在堆上的，update
         * 2. 没进过堆的，new
         * 3. 进过堆但是不在堆上的，ignore
         * */
        public void addOrUpdateOrIgnore(Node node,int distance){
            //第一种情况：已经在堆上
            if (inHeap(node)){
                distanceMap.put(node,Math.min(distanceMap.get(node),distance));
                //冒泡
                insertHeapify(node,heapIndexMap.get(node));
            }
            //第二种情况：新进的节点，放在最后一个位置
            if (!isEntered(node)){
                nodes[size]=node;
                heapIndexMap.put(node,size);
                distanceMap.put(node,distance);
                //新加入，冒泡
                insertHeapify(node,size++);
            }
            //第三种情况：已经被考察完的节点，不做处理

        }
        public NodeRecord pop(){
            //弹出根节点
            NodeRecord nodeRecord=new NodeRecord(nodes[0],distanceMap.get(nodes[0]));
            //将到根节点的距离标为-1
            swap(0,size-1);
            //将要弹出的节点的下标表示成-1
            heapIndexMap.put(nodes[size-1],-1);
            //从距离map中删除该节点信息
            distanceMap.remove(nodes[size-1]);
            nodes[size-1]=null;
            //从新的根节点开始往下移动一轮
            heapify(0,--size);
            return nodeRecord;
        }
        //堆上节点
        private Node[] nodes;
        //key为堆上节点，value为该节点在堆上的位置
        private HashMap<Node,Integer> heapIndexMap;
        //key为堆上节点，value为A节点到该节点的距离
        private HashMap<Node,Integer> distanceMap;
        //堆上节点个数
        private int size;
        public NodeHeap(int size) {
            this.nodes = new Node[size];
            this.heapIndexMap = new HashMap<>();
            this.distanceMap = new HashMap<>();
            this.size=0;
        }
        public boolean isEmpty(){
            return size==0;
        }

        //标志一个节点是否进过堆
        private boolean isEntered(Node node){
            return heapIndexMap.containsKey(node);
        }
        //判断一个节点是不是在堆上
        private boolean inHeap(Node node){
            return isEntered(node) && heapIndexMap.get(node)!=-1;
        }
        //交换两个节点
        private void swap(int index1,int index2){
            heapIndexMap.put(nodes[index1],index2);
            heapIndexMap.put(nodes[index2],index1);
            Node temp=nodes[index1];
            nodes[index1]=nodes[index2];
            nodes[index2]=temp;
        }


        public static class NodeRecord{
            private Node node;
            private int distance;

            public NodeRecord(Node node, int distance) {
                this.node = node;
                this.distance = distance;
            }
        }

        //向下移动
        private void heapify(int index, int size) {
            int left=index*2+1;
            while (left<size){
                int min=left+1<size&&distanceMap.get(nodes[left])<distanceMap.get(nodes[left+1])?left:left+1;
                min=distanceMap.get(nodes[min])<distanceMap.get(nodes[index])?min:index;
                if (min==index){
                    return;
                }
                swap(min,index);
                index=min;
                left=index*2+1;
            }
        }
        //距离小的节点往上窜
        private void insertHeapify(Node node, Integer index) {
            while (distanceMap.get(nodes[index])<distanceMap.get(nodes[(index-1)/2])){
                swap(index,(index-1)/2);
                index=(index-1)/2;
            }
        }
    }
}

```

### 前缀树

```java
package tree;

/*
 * 前缀树
 * */
public class TrieTree {
    /*
     * 前缀树根节点
     * */
    private TrieNode root;

    /*
     * 前缀树节点
     * */
    public class TrieNode {
        int pass;
        int end;
        TrieNode[] next;

        public TrieNode() {
            this.pass = 0;
            this.end = 0;
            /*
             * 每个节点都可以走向26条路
             * next[0]!=null 说明该节点有走向'a'的路
             * next[1]!=null 说明该节点有走向'b'的路
             * ....
             * next[2]!=null 说明该节点有走向'c'的路
             * */
            this.next = new TrieNode[26];
        }
    }

    public TrieTree() {
        this.root = new TrieNode();
    }

    /*
     * 添加字符串
     * */
    public void insert(String word) {
        if (word == null) {
            return;
        }
        char[] chars = word.toCharArray();
        TrieNode cur = root;
        root.pass++;
        int index = 0;
        for (int i = 0; i < chars.length; i++) {
            index = chars[i] - 'a';
            if (cur.next[index] == null) {
                cur.next[index] = new TrieNode();
            }
            cur = cur.next[index];
            cur.pass++;
        }
        cur.end++;
    }

    /*
     * 删除字符串，删一次就行。。
     * */
    public boolean delete(String word) {
        if (word == null || search(word)==0) {
            return false;
        }
        char[] chars = word.toCharArray();
        TrieNode cur = root;
        root.pass--;
        int index=0;//其实可以不赋值的
        for (char c : chars) {
            index = c - 'a';
            if (cur.next[index] != null && --cur.next[index].pass == 0) {
                cur.next[index] = null;
                return true;
            }
            //上面的判断就算不成立pass值也已经减了
            cur = cur.next[index];
        }
        cur.end--;
        return true;
    }

    /*
     * 查看字符串之前加入过几次
     * */
    public int search(String word) {
        if (word == null) {
            return 0;
        }
        char[] chars = word.toCharArray();
        TrieNode cur = root;
        int index = 0;
        for (char aChar : chars) {
            index = aChar - 'a';
            if (cur.next[index] == null) {
                return 0;
            }
            cur = cur.next[index];
        }
        return cur.end;
    }

    /*
     * 所有加入的字符串中，有几个字符串是以pre为前缀的
     * */
    public int prefixNumber(String pre) {
        if (pre == null) {
            return 0;
        }
        char[] chars = pre.toCharArray();
        TrieNode cur = root;
        int index = 0;
        for (char aChar : chars) {
            index = aChar - 'a';
            if (cur.next[index] == null) {
                return 0;
            }
            cur = cur.next[index];
        }
        return cur.pass;
    }
}

```

### 贪心算法

在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的的样本，最终得到一个答案的算法，叫做贪心算法。也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。

#### 安排最多的会议

```java

package greedyAlgprithm;
import java.util.Arrays;
import java.util.Comparator;

/*
* 贪心算法
* */
public class BestArrange {
    /*
    * 会议
    * 有开始时间和结束时间
    * */
    public class Program{
        int start;
        int end;
    }
    /*
    * 会议比较器
    * 按结束时间从小到大排序
    * */
    public class ProgramComparator implements Comparator<Program>{
        @Override
        public int compare(Program o1, Program o2) {
            return o1.end-o2.end;
        }
    }

    /*
    * 什么顺序安排会议才能使被安排的会议数量最大
    * */
    public int bestArrange(Program[] programs, int timePoint) {
        int count = 0;
        //数组排序传比较器直接调Arrays.sort()就行
        Arrays.sort(programs,new ProgramComparator());
         for (Program cur:programs) {
            if (cur.start >= timePoint) {
                count++;
                timePoint = cur.end;
            }
        }
        return count;
    }

}

```

#### 利润最大化

```java
package greedyAlgprithm;
import java.util.Comparator;
import java.util.PriorityQueue;
/*
* 贪心算法
* 在规定能做的项目最大个数的情况下做出利润最大化
* */
public class IPO {
    public static class Node{
        int capital;
        int profit;

        public Node(int capital, int profit) {
            this.capital = capital;
            this.profit = profit;
        }
    }

    public static class MinCostComparator implements Comparator<Node>{

        @Override
        public int compare(Node o1, Node o2) {
            return o1.capital -o2.capital;
        }
    }
    public static class MaxProfitComparator implements Comparator<Node>{

        @Override
        public int compare(Node o1, Node o2) {
            return o2.profit-o1.profit;
        }
    }

    public static int ipo(int[] profits,int[] capital,int w,int k){
        //w为初始资金 k为最多能做的项目个数
        PriorityQueue<Node> minCostQ=new PriorityQueue<>(new MinCostComparator());
        PriorityQueue<Node> maxProfitQ=new PriorityQueue<>(new MaxProfitComparator());
        for (int i = 0; i < profits.length; i++) {
            minCostQ.add(new Node(capital[i],profits[i]));
        }
        for (int i = 0; i < k; i++) {
            //解锁所有启动资金小于当前所拥有的资金的项目
            while (!minCostQ.isEmpty() && minCostQ.peek().capital<=w){
                maxProfitQ.add(minCostQ.poll());
            }
            //没有能做的项目，直接返回
            if (maxProfitQ.isEmpty()){
                break;
            }
            //在能做的项目中选出利润最大的项目来做，做完更新当前资金
            w +=maxProfitQ.poll().profit;
        }
        return w;
    }
}

```

#### 切分金条

```java
package greedyAlgprithm;
import java.util.PriorityQueue;

/*
* 贪心算法
* 用最少的铜板切分金条
* */
public class LessMoneySplitGold {
    public static int lessMoneySplitGold(int[] arr){
        int sum=0;
        //小根堆
        PriorityQueue<Integer> queue=new PriorityQueue<>();
        for (int i : arr) {
            queue.add(i);
        }
        int cur;
        while (queue.size()>1){
            cur=queue.poll()+queue.poll();
            sum+=cur;
            queue.add(cur);
        }
        return sum;
    }

}

```

#### 最小字典序

```java
package greedyAlgprithm;

import java.util.Arrays;
import java.util.Comparator;

/*
* 贪心算法
* 按照最小字典序进行排序
* */
public class LowestLexicography {
    public static class StringComparator implements Comparator<String>{

        @Override
        public int compare(String o1, String o2) {
            return (o1+o2).compareTo(o2+o1);
        }
    }
    public static String lowestLexicography(String[] strings){
        if (strings==null || strings.length==0){
            return "";
        }
        StringBuilder result= new StringBuilder();
        Arrays.sort(strings, new StringComparator());
        for (String string : strings) {
            result.append(string);
        }
        return result.toString();
    }
}

```

#### N皇后问题

```java
package greedyAlgprithm;
/*
* 贪心算法
* N皇后问题
* 还有一个位运算能够改善常熟级别的但是没听懂。。。
* */
public class Num {
    /*
    * 经典解法
    * */
    public static int num(int n){
        if (n<1){
            return 0;
        }
        int[] record=new int[n];
        return process(n,0,record);
    }

    /*
    * 潜台词：record[0...i-1]上的任何两个皇后都不共行，不共列，也不共斜线
    * 目前来到了第i行
    * record[0..i-1]表示0到i-1行放了皇后的位置
    * n代表整体有多少行
    * 返回值是摆完所有的皇后，合理的摆法有多少种
    * */
    private static int process(int n, int i, int[] record) {
        if (n==i){//终止行
            return 1;
        }
        int sum=0;
        for (int j = 0; j < n; j++) {//当前在i行，尝试i行所有的列
            if (isValid(record,i,j)){//判断能不能放（i,j)位置
                record[i]=j;//满足条件，放皇后
                sum+=process(n,i+1,record);//放该位置后，下面的行有多少种合理摆法，进行统计
            }
        }
        return sum;//返回所有合理摆法的统计结果
    }

    /*
    * 查看如果把皇后放在(i,j)的位置
    * 是否和record[0....i-1]上已经摆放好的皇后冲突
    * 只要判断不共行和不共斜线就行，因为不在同一行，所有不会共行
    * */
    private static boolean isValid(int[] record, int i, int j) {
        for (int k = 0; k < i; k++) {//i行之前的某个k行的皇后
            if (record[k]==j || Math.abs(i-k)==Math.abs(record[k]-j)){
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        num(14);
        System.out.println("cost time :"+(System.currentTimeMillis() - start)+"ms");

    }
}

```

## KMP算法

```java
/*
* KMP算法
* */
public class KMP {
    public static int getIndexOf(String s1,String s2){
        if (s1==null || s2==null || s2.length()<1 || s2.length()>s1.length()){
            return -1;
        }
        int i1=0;
        int i2=0;
        int[] next= getNextArray(s2.toCharArray());//O(M)
        //O(N)
        while (i1<s1.length()&&i2<s2.length()){
            if (s1.charAt(i1)==s2.charAt(i2)){
                i1++;
                i2++;
            } else if (next[i2] == -1) {
                i1++;
            }else{
                i2=next[i2];
            }
        }
        return i2==s2.length()?i1-i2:-1;
    }

    private static int[] getNextArray(char[] chars) {
        if (chars.length==1){
            return new int[]{-1};
        }
        int[] next=new int[chars.length];
        next[0]=-1;
        next[1]=0;
        int i=2;
        int cn=0;//int cn=next[1];
        while (i<next.length){
            if (chars[i-1]==chars[cn]){
                next[i++]=++cn;
            }else if(cn>0){
                cn=next[cn];
            }else{
                next[i++]=0;
            }
        }
        return next;
    }
}

```

## Manacher算法

```java
package datastructures;
/*
* 求最大回文串长度
* */
public class Manacher {

    /*
    * 用'#'对原始字符串进行填充
    * */
    public static char[] manacherString(String str){
        char[] chars = str.toCharArray();
        char[] res=new char[str.length()*2+1];
        int index=0;
        for (int i = 0; i < res.length; i++) {
            res[i]=(i & 1)==0?'#':chars[index++];
        }
        return res;
    }

    public static int maxLcpsLength(String str){
        char[] chars = manacherString(str);//得到填充后的字符串
        int[] pArr=new int[chars.length];
        int r=-1;//所有以c为中心扩的回文串中最靠右的右边界+1
        int c=-1;
        int max=Integer.MIN_VALUE;
        for (int i = 0; i < chars.length; i++) {
            //先找出不需要考虑的范围
           pArr[i]= r>i?Math.min(r-i,pArr[c*2-i]):1;// i>=r时，pArr[i]=1暴力扩！不用考虑的区域只有自己
            //r>i时，i分在边界上和边界内两种情况，在边界上那么pArr[i]=r-i=1（因为r-i<=pArr[c*2-i])
            // 边界内那么就是Math.min(r-i,pArr[c*2-i])
           while (i+pArr[i]<chars.length && i-pArr[i]>-1){
               if (chars[i+pArr[i]]==chars[i-pArr[i]]){
                   pArr[i]++;
               }else{
                   break;
               }
           }
           //判断暴力扩有没有扩出最右边界，有则更新r
           if (i+pArr[i]>r){
               r=i+pArr[i];
               c=i;
           }
           //更新最大回文半径
           max=Math.max(max,pArr[i]);
        }
        //返回最大回文串长度-》原始串的最大回文串长度=填充串的最大回文半径-1
        return max-1;
    }

    public static void main(String[] args) {
        System.out.println(maxLcpsLength("01213210"));
    }
}

```

## 并查集

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;
/*
* 并查集
* */
public class UnionFindSetDemo {

    public static class Element<V>{
        public V value;
        public Element(V value) {
            this.value = value;
        }
    }
    public static class UnionFindSet<V>{
        public HashMap<V,Element<V>> elementMap;
        public HashMap<Element<V>,Element<V>> fatherMap;
        public HashMap<Element<V>,Integer> sizeMap;

        public UnionFindSet(List<V> values) {
            this.elementMap=new HashMap<>();
            this.fatherMap=new HashMap<>();
            this.sizeMap=new HashMap<>();
            for (V value : values) {
                Element<V> element = new Element<>(value);
                elementMap.put(value,element);
                fatherMap.put(element,element);
                sizeMap.put(element,1);
            }
        }

        public boolean isSameSet(V a, V b){
            if (elementMap.containsKey(a) && elementMap.containsKey(b)){
                return findHeap(elementMap.get(a)) == findHeap(elementMap.get(b));
            }
            return false;
        }

        public void union(V a,V b){
            if (elementMap.containsKey(a) && elementMap.containsKey(b)){
                if (!isSameSet(a, b)){
                    Element<V> heap1 = findHeap(elementMap.get(a));
                    Element<V> heap2 = findHeap(elementMap.get(b));
                    Element<V> big = sizeMap.get(heap1) > sizeMap.get(heap2) ? heap1 : heap2;
                    Element<V> small = big == heap1 ? heap2 : heap1;
                    fatherMap.put(small,big);
                    sizeMap.put(big,sizeMap.get(heap1)+sizeMap.get(heap2));
                    sizeMap.remove(small);
                }
            }
        }

        private Element<V> findHeap(Element<V> element) {
            Stack<Element<V>> path =new Stack<>();
            while (element!=fatherMap.get(element)){
                path.push(element);
                element=fatherMap.get(element);
            }
            while (!path.isEmpty()){
                fatherMap.put(path.pop(),element);
            }
            return element;
        }
    }

    public static void main(String[] args) {
        List<Integer> list=new ArrayList<>();
        for (Integer integer : list) {
            System.out.println(integer);
        }
    }
}

```

## 滑动窗口问题

### 求窗口中位数

大根堆和小根堆 风险对冲

```java
package datastructures.heap;
/*
* 滑动窗口求中位数问题
* */
public class Solution {
    public static double[] medianSlidingWindow(int[] nums, int k) {
        if (nums==null|| k<1 || k>nums.length){
            return null;
        }
        double[] res=new double[nums.length-k+1];
        DualHeap dh=new DualHeap(k);
        for (int i = 0; i < k; i++) {
            dh.insert(nums[i]);
        }
        res[0]=dh.getMedian();
        for (int i = k; i < nums.length; i++) {
            dh.insert(nums[i]);
            dh.erase(nums[i-k]);//删除过期窗口位置
            res[i-k+1]=dh.getMedian();
        }
        return res;
    }

    public static void main(String[] args) {
        for (double v : medianSlidingWindow(new int[]{-2147483648,-2147483648,2147483647,-2147483648,-2147483648,
                -2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648}, 3)) {
            System.out.print(v+" ");
        }
    }
}

```

```java
package datastructures.heap;

import java.util.HashMap;
import java.util.PriorityQueue;
/*
* 定义一种数据结构解决滑动窗口求中位数问题
* */
public class DualHeap {
    private PriorityQueue<Integer> small;
    private PriorityQueue<Integer> large;
    private HashMap<Integer,Integer> delay;
    private int smallSize;
    private int largeSize;
    private int k;
    public DualHeap(int k){
        this.large=new PriorityQueue<>();
        this.small=new PriorityQueue<>( ( o1,o2) -> o2.compareTo(o1));//直接用减号会出现溢出！！！😉😉🤷‍♀️
        this.delay=new HashMap<>();
        this.largeSize=0;
        this.smallSize=0;
        this.k=k;

    }
    /*
    * 获取中位数
    * */
    public double getMedian(){
        return (k&1)==1?
                (double)small.peek():
                ((double)small.peek()/2+(double) large.peek()/2);
    }
    /*
    * 插入数据
    * */
    public void insert(int num){
        if (small.isEmpty() || num<=small.peek()){
            small.offer(num);
            ++smallSize;
        }else{
            large.offer(num);
            ++largeSize;
        }
        makeBalance();//每次加入一个元素都要判断是否需要调整
    }
    /*
    * 延迟删除！在调整过程中该元素到堆顶时才会真正从结构中删除
    * 但是大根堆和小根堆的大小是删除元素后的实际值，会严格按照规则分布，
    * 尽管延迟删除堆顶元素就是实际的中位数(k奇数时大根堆的堆顶；k偶数时大根堆和小根堆堆顶的平均值)
    * 延迟元素只要不在堆顶参与计算也不影响实际的数据排序和分布，就不会影响最终结果
    * */
    public void erase(int num){
        delay.put(num,delay.getOrDefault(num,0)+1);
        if (num<=small.peek()){
            --smallSize;
            if (num==small.peek()){//如果要删除的元素在堆顶直接删除
                prune(small);
            }
        }else{
            --largeSize;
            if (num==large.peek()){
                prune(large);
            }
        }
        makeBalance();//根据实际的堆大小进行调整
    }
    /*
    * 满足small.size()-large.size()==1 k为奇数 这时small.peek()就是中位数
    * 或者 small.size()-large.size()==0 k为偶数 这时中位数是small.peek()和large.peek()的平均值
    * */
    private void makeBalance() {
        if (smallSize-largeSize>1){
            large.offer(small.poll());
            --smallSize;
            ++largeSize;
            prune(small);//检查新堆顶是不是延迟删除的，如果是，那么在堆顶时删除
        }
        if (largeSize>smallSize){
            small.add(large.poll());
            ++smallSize;
            --largeSize;
            prune(large);//检查新堆顶是不是延迟删除的，如果是，那么在堆顶时删除
        }
    }
    // 如果堆顶是延迟删除过的元素，不断地弹出 heap 的堆顶元素，并且更新哈希表
    private void prune(PriorityQueue<Integer> heap) {
        while (!heap.isEmpty()){
            Integer num = heap.peek();
            if (delay.containsKey(num)){
                delay.put(num,delay.get(num)-1);
                if (delay.get(num)==0){//该元素已删干净，可以移除map
                    delay.remove(num);
                }
                heap.poll();//只要在堆顶出现延迟删除过的元素，趁在堆顶，马上删除
            }else{
                break;
            }
        }
    }
}

```

### 求窗口中最大值

双端队列

```java

/*
 * 滑动窗口
 * 使用双端队列LinkedList：两端既可以插入也可以删除
 * */
public class SlidingWindow {

    public static int[] get(int[] arr, int w) {
        if (arr == null || w < 1 || arr.length < w) {
            return null;
        }
        int[] res = new int[arr.length - w + 1];
        LinkedList<Integer> list = new LinkedList<>();
        int r = 0;
        int index = 0;
        while (r < arr.length) {
            //严格保证加入元素后保持有序
            while (!list.isEmpty() && arr[r] >= arr[list.peekLast()]) {
                list.pollLast();
            }
            list.add(r);
            //保证最大值属于有效范围
            if (list.peekFirst() == r - w) {
                list.pollFirst();
            }
            if (r - w + 1 >= 0) {//窗口形成了
                res[index++] = arr[list.getFirst()];
            }
            r++;


 }
        return res;
    }

}
```

## 接雨水问题

```java
package datastructures.stack;

import java.util.*;
import java.util.Stack;

/*
* 单调栈
* */
public class MonotoneStack {

    /*
    * 接雨水问题
    * */
    public static int trap(int[] height) {
        int res=0;
        java.util.Stack<Integer> stack = new java.util.Stack<>();
        for (int i = 0; i < height.length; ) {
            if (stack.isEmpty() || height[i] <= height[stack.peek()]) {
                stack.push(i);
                i++;
            } else {
                int midHeight=height[stack.pop()];
                int leftHeight=!stack.isEmpty()?height[stack.peek()]:0;
                int leftIndex=!stack.isEmpty()?stack.peek():-1;
                if (leftHeight>midHeight){
                    res+=(i-leftIndex-1)*(Math.min(leftHeight,height[i])-midHeight);
                }
            }
        }
        return res;
    }

    public static HashMap<Integer, List<Integer>> get(int[] arr) {
        java.util.Stack<Integer> stack = new java.util.Stack<>();
        HashMap<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < arr.length; ) {
            if (stack.isEmpty() || arr[i] > arr[stack.peek()]) {
                stack.push(i);
                i++;
            } else {
                Integer index = stack.pop();
                ArrayList<Integer> list = new ArrayList<>();
                list.add(!stack.isEmpty()?stack.peek():-1);//左边比自己小且最近的位置
                list.add(i);//右边比自己小的位置
                map.put(index, list);
            }
        }
        //最后结算
        while (!stack.isEmpty()){
            Integer index = stack.pop();
            ArrayList<Integer> list = new ArrayList<>();
            list.add(!stack.isEmpty()?stack.peek():-1);//左边比自己小且最近的位置
            list.add(-1);//右边比自己小的位置
            map.put(index, list);
        }
        return map;
    }

    public static HashMap<Integer, List<Integer>> get2(int[] arr) {
        java.util.Stack<LinkedList<Integer>> stack = new Stack<>();
        HashMap<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < arr.length; ) {
            if (stack.isEmpty() || arr[i] > arr[stack.peek().peekLast()]) {
                LinkedList<Integer> list= new LinkedList<>();
                list.offerLast(i++);
                stack.push(list);
            }else if(arr[i] == arr[stack.peek().peekLast()]){
                stack.peek().offerLast(i++);
            } else {
                LinkedList<Integer> list=stack.pop();
                while (!list.isEmpty()){
                    int index=list.pollLast();
                    ArrayList<Integer> res = new ArrayList<>();
                    res.add(!stack.isEmpty()?stack.peek().peekLast():-1);//左边比自己小且最近的位置
                    res.add(i);//右边比自己小的位置
                    map.put(index, res);
                }
            }
        }
        //最后结算
        while (!stack.isEmpty()){
            LinkedList<Integer> list=stack.pop();
            while (!list.isEmpty()){
                int index=list.pollLast();
                ArrayList<Integer> res = new ArrayList<>();
                res.add(!stack.isEmpty()?stack.peek().peekLast():-1);//左边比自己小且最近的位置
                res.add(-1);//右边比自己小的位置
                map.put(index, res);
            }
        }
        return map;
    }

    public static void main(String[] args) {
        int[] arr={5, 4, 4,2,2,6, 7, 2, 3, 0, 1};
        HashMap<Integer, List<Integer>> map = get2(arr);
        for (Integer key : map.keySet()) {
            System.out.println(arr[key]+" 左"+map.get(key).get(0)+" 右 "+map.get(key).get(1));
        }

        System.out.println(trap(new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}));

    }
}

```

## 树形dp

```java
package datastructures.violentRecursion;
import datastructures.tree.TreeNode;

import java.util.HashMap;
/*
* 树形dp
* */
public class MaxDistance {
    public static int maxDistance(TreeNode head){
        return process(head).maxDistance;
    }
    public static class Info{
        private int maxDistance;
        private int height;

        public Info(int distance, int height) {
            this.maxDistance = distance;
            this.height = height;
        }
    }
    public static Info process(TreeNode head){
        if (head==null){
            return new Info(0,0);//一定要选好baseCase
        }
        Info leftInfo = process(head.left);
        Info rightInfo = process(head.right);
        int height=Math.max(leftInfo.height,rightInfo.height)+1;
        int maxDistance=Math.max(leftInfo.maxDistance,rightInfo.maxDistance);
        maxDistance=Math.max(maxDistance,leftInfo.height+rightInfo.height+1);
        return new Info(maxDistance,height);
    }

    public static HashMap<String,Integer> processX(TreeNode head){
        HashMap<String,Integer> infoMap=new HashMap<>();
        if (head==null){
            infoMap.put("height",0);
            infoMap.put("distance",0);
            return infoMap;
        }
        HashMap<String, Integer> leftInfo = processX(head.left);
        HashMap<String, Integer> rightInfo = processX(head.right);
        infoMap.put("height", Math.max(leftInfo.get("height"),rightInfo.get("height"))+1);
        int maxDistance=Math.max(leftInfo.get("maxDistance"),rightInfo.get("maxDistance"));
        maxDistance=Math.max(maxDistance,leftInfo.get("height")+rightInfo.get("height")+1);
        infoMap.put("distance",maxDistance);
        return infoMap;
    }
}

```

## 派对最大快乐值

```java
package datastructures.violentRecursion;

import java.util.List;
/*
* 派对最大快乐值
* */
public class Happy {

    public static class Employee{
        public int happy;
        List<Employee> subordinates;

        public Employee(int happy, List<Employee> subordinates) {
            this.happy = happy;
            this.subordinates = subordinates;
        }
    }

    public static class Info{
        private int joinMax;
        private int  unJoinMax;

        public Info(int joinMax, int unJoinMax) {
            this.joinMax = joinMax;
            this.unJoinMax = unJoinMax;
        }
    }

    public static int getMaxHappy(Employee employee){
        Info info = process(employee);
        return Math.max(info.joinMax,info.unJoinMax);
    }
    public static Info process(Employee employee){
        if (employee.subordinates==null){//基层员工
            return new Info(employee.happy,0);
        }
        int joinMax=employee.happy;
        int unJoinMax=0;
        for (Employee subordinate : employee.subordinates) {
            Info info = process(subordinate);
            joinMax+=info.unJoinMax;
            unJoinMax+=Math.max(info.joinMax,info.unJoinMax);
        }
        return new Info(joinMax,unJoinMax);
    }

    public static int process2(Employee employee, boolean join){
        if (employee==null){
            return 0;
        }
        //当前员工不能参与活动
        if (!join){
            int res=0;
            for (Employee subordinate : employee.subordinates) {
                res+=Math.max(process2(subordinate,true), process2(subordinate,false));
            }
            return res;
        }
        //当前员工可参与也可不参与活动
        //1.选择参与
        int res1=0;
        res1+=employee.happy;
        for (Employee subordinate : employee.subordinates) {
            res1+= process2(subordinate,false);
        }
        //2.选择不参与
        int res2=0;
        for (Employee subordinate : employee.subordinates) {
            res2+=Math.max(process2(subordinate,true), process2(subordinate,false));
        }
        return Math.max(res1,res2);


    }

}

```

## Morris遍历

```java
package datastructures.tree;
/*
* MorrisNode实现二叉树遍历
* 不是系统压栈，是改变叶节点的指针指向
* */
public class MorrisNode {
    public static void morrisNode(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//过流程
            mostRight=cur.left;//找cur左子树上的最右节点，从左子树头节点开始寻找mostRight
            if (mostRight!=null){//有左子树
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//这是第一次来到cur
                    System.out.println(cur.val);
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//之前来过cur,接下来要移到cur.right
                }
            }
            cur=cur.right;//cur没有左子树或者已经走完左子树
        }

    }

    /*
    * morris实现二叉树先序遍历
    * */
    public static void morrisPre(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//过流程
            mostRight=cur.left;//找cur左子树上的最右节点，从左子树头节点开始寻找mostRight
            if (mostRight!=null){//有左子树
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//这是第一次来到cur
                    System.out.println(cur.val);
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//之前来过cur,接下来要移到cur.right
                }
            }else{
                System.out.println(cur.val);
            }
            cur=cur.right;//cur没有左子树或者已经走完左子树
        }

    }

    /*
     * morris实现二叉树中序遍历
     * */
    public static void morrisIn(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//过流程
            mostRight=cur.left;//找cur左子树上的最右节点，从左子树头节点开始寻找mostRight
            if (mostRight!=null){//有左子树
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//这是第一次来到cur
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//之前来过cur,接下来要移到cur.right
                }
            }
            System.out.println(cur.val);//第二次来到cur和没有左子树时打印
            cur=cur.right;//cur没有左子树或者已经走完左子树
        }

    }

    /*
     * morris实现二叉树后序遍历
     * */
    public static void morrisAfter(TreeNode head){
        if (head ==null){
            return;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while (cur!=null){//过流程
            mostRight=cur.left;//找cur左子树上的最右节点，从左子树头节点开始寻找mostRight
            if (mostRight!=null){//有左子树
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//这是第一次来到cur
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//之前来过cur,接下来要移到cur.right
                    printEdge(cur.left);//第二次到达某节点时打印该节点的左子树右边界
                }
            }
            cur=cur.right;//cur没有左子树或者已经走完左子树
        }
        printEdge(head);//最后打印整棵树的右边界
        System.out.println();

    }
    /*
    * 逆序打印以x为头的这颗树的右边界
    * */
    public static void printEdge(TreeNode x){
        TreeNode tail=reverse(x);
        TreeNode cur=tail;
        while (cur!=null){
            System.out.print(x.val+" ");
            cur=cur.right;
        }
        reverse(tail);
    }

    private static TreeNode reverse(TreeNode from) {
        TreeNode pre=null;
        TreeNode next =null;
        while (from !=null){
            next = from.right;
            from.right=pre;
            pre= from;
            from = next;
        }
        return pre;
    }
}
```

## 哈希表

1. HashSet 
   只有key，没有伴随数据value

2. HashMap
   既有key，又有伴随数据value

使用哈希表进行增删改查都可以认为是时间复杂度为O(1)级别，但是常熟时间比较大；放入哈希表的东西如果是基础类型，内部按值传递，内存占用就是这个东西的大小，如果不是基础类型，内存占用的就是这个东西内存地址的大小。

### RandomPool结构

```java
package hash;

import java.util.HashMap;
import java.util.Random;
/*
* 设计一个RandomPoll结构
* insert(key)不重复加入key
* delete(key)移除key
* getRandom()等概率随机返回结构中的任何一个key
* 时间复杂度都是key
* */
public class RandomPoll<K>{
    private HashMap<K,Integer> keyIndexMap;
    private HashMap<Integer,K> indexKeyMap;
    private int size;

    public RandomPoll(){
        this.keyIndexMap = new HashMap<>();
        this.indexKeyMap = new HashMap<>();
        this.size = 0;
    }
    public RandomPoll(HashMap<K, Integer> keyIndexMap, HashMap<Integer, K> indexKeyMap, int size) {
        this.keyIndexMap = keyIndexMap;
        this.indexKeyMap = indexKeyMap;
        this.size = size;
    }
    /*
     * 插入key
     * */
    public void insert(K key){
        if (!keyIndexMap.containsKey(key)){
            keyIndexMap.put(key,size);
            indexKeyMap.put(size++,key);
        }
    }
    /*
     * 删除key
     * */
    public void delete(K key){
        //删除前判断key是否在哈希表中
        if (keyIndexMap.containsKey(key)){
            Integer index = keyIndexMap.get(key);
            keyIndexMap.put(indexKeyMap.get(size-1),index);
            indexKeyMap.put(index,indexKeyMap.get(size-1));
            keyIndexMap.remove(key);
            indexKeyMap.remove(--size);
        }
    }
    /*
     * 等概率随机返回结构中的任何一个key
     * */
    public K getRandom(){
        Random r=new Random();
        int randomIndex = r.nextInt(size);
//            int randomIndex = (int)(Math.random() * this.size);//0~size-1
        return indexKeyMap.get(randomIndex);
    }
}

```

## 有序表

1. TreeSet
   只有key，没有伴随数据value

2. TreeMap
   既有key，又有伴随数据value

哈希表和有序表的区别是，有序表把key按照顺序组织起来，哈希表的key则没有顺序；放入有序表的东西如果是基础类型，内部按值传递，内存占用就是这个东西的大小，如果不是基础类型，必须提供比较器，内存占用的就是这个东西内存地址的大小；有序表的所有操作的时间复杂度都是O(logN),N为有序表含有的记录数。





## 暴力递归

### 汉诺塔

```java
package violentRecursion;

/*
 *  暴力递归
 *  哈诺塔经典问题
 * */
public class Hanoi {
    public static void hanoi(int n) {
        process(n, "左", "右", "中");
    }

    private static void process(int n, String start, String end, String other) {
        if (n == 1) {
            System.out.println("Move 1 from " + start + " to " + end);
            return;
        }

        process(n - 1, start, other, end);
        System.out.println("Move " + n + " from " + start + " to " + end);
        process(n - 1, other, end, start);

    }

    public static void main(String[] args) {
        hanoi(15);
    }
}

```

### 纸牌

```java

package violentRecursion;

/*
* 暴力递归
* 数值不同的牌排成一条线，玩家A和玩家B依次拿走每一张牌，规定玩家A先拿，玩家B后拿
* 一个玩家只能拿走最左或最右的牌，玩家A和玩家B都绝顶聪明，请返回最后获胜者的分数
* */
public class CardsInline {
    public static int win(int[] arr){
        if (arr==null || arr.length==0){
            return 0;
        }
        //0到arr.length-1范围上，一个玩家当先手，另一个玩家当后手
        return Math.max(first(arr,0,arr.length-1),second(arr,0,arr.length-1));
    }
    //先手玩家
    public static int first(int[] arr,int l,int r){
        if (l==r){
            return arr[l];
        }
        //作为先手，我会选择对我自己最有利的，所以选max
        return Math.max(arr[l]+second(arr,l+1,r),arr[r]+second(arr,l,r-1));
    }
    //后手玩家
    public static int second(int[] arr,int l,int r){
//        如果l==r，作为后手，这唯一的牌会被先手拿走，所以只能返回0
        if (l==r){
            return 0;
        }
        //作为后手，先手会把最坏的情况给我，所以选min
        return Math.min(first(arr,l+1,r),first(arr,l,r-1));
    }
}

```

### 打印所有排列

```java
package violentRecursion;

import java.util.ArrayList;

/*
 * 暴力递归
 * 打印所有排列
 * */
public class PrintAllPermutations {

    public static void process(char[] str, int i, ArrayList<String> res) {
        if (i == str.length) {
            res.add(String.valueOf(str));
            return;
        }
        boolean[] visit = new boolean[26];//visit[0]=true 说明a参与过交换 visit[1]=true说明b参与过交换
        // 是为了避免i位置和不同位置却相同字符的位置交换，最终产生相同的字符串
        for (int j = i; j < str.length; j++) {
            if (!visit[str[j] - 'a']) {
                visit[str[j] - 'a'] = true;
                swap(str, i, j);
                process(str, i + 1, res);
                swap(str, i, j);
            }
        }
    }

    private static void swap(char[] str, int i, int j) {
        char temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }

    public static void main(String[] args) {
        String str = "abca";
        char[] chars = str.toCharArray();
        ArrayList<String> list = new ArrayList<>();
        process(chars, 0, list);
        for (String s : list) {
            System.out.println(s);
        }
    }
}

```

### 字符串子序列

```java
package violentRecursion;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.Collectors;

/*
* 暴力递归
* 打印一个字符串的所有子序列，包括空字符串
* */
public class SubsequenceOfString {
    public static void function(String str){

        ArrayList<Character> res = new ArrayList<>();
        char[] chars = str.toCharArray();
        process(0,chars,res);
        process2(chars,0);
    }
    public static ArrayList<String> strings=new ArrayList<>();
    private static void process(int i, char[] chars, ArrayList<Character> res) {
        if (i==chars.length){
            /*if (!res.isEmpty()){
                String str = res.stream().map(Object::toString).collect(Collectors.joining());
                strings.add(str);
            }else{
                strings.add("");
            }*/
            String str = res.stream().map(Object::toString).collect(Collectors.joining());
            strings.add(str);
            return;
        }
//        ArrayList<Character> yes=res;//这是引用啊大傻妞卧槽！！！也会改变res的值
        ArrayList<Character> yes=copy(res);
        yes.add(chars[i]);
        process(i+1,chars,yes);
        ArrayList<Character> no=copy(res);
        process(i+1,chars,no);
    }
    private static ArrayList<Character> copy(ArrayList<Character> res) {
        return new ArrayList<>(res);//一定要new一个新的list，不然就是对原集合的引用，会改变原集合的值
    }

    /*
    * 来到当前位置，要和不要，走两条路
    * 之前的选择形成的结果是str
    * */
    public static void process2(char[] str,int i){
        if (i==str.length){
            System.out.println(Arrays.toString(str));
            return;
        }
        process2(str,i+1);//要当前的字符
        char temp=str[i];
        str[i]=0;
        process2(str,i+1);//不要当前的字符
        str[i]=temp;
    }

    public static void main(String[] args) {
        function("abc");
        for (String string : strings) {
            System.out.println(string);
        }
        System.out.println(strings.size());
    }
}

```

### 数字字符串

```java
package violentRecursion;
/*
* 规定1对应A，2对应B，3和C对应以此类推
* 那么一个数字字符串"111",就可以转化成"AAA","KA","AK"
* 返回有多少种转化结果
* * */
public class ConvertToLetterString {

    public static void function(String str){
        char[] chars = str.toCharArray();
        StringBuilder sb=new StringBuilder();
        System.out.println("总共有"+s(chars, 0, sb)+"种组合方式");
    }
    public static int s(char[] str,int i,StringBuilder sb){
        if (i==str.length){
            System.out.println(sb.toString());
            return 1;
        }
        if (str[i]=='0'){
            sb.delete(0,sb.length());
            return 0;
        }
        if (str[i]=='1'){
            StringBuilder sb1=new StringBuilder();
            sb1.append(sb.toString());
            sb1.append(getChar(str[i]));//加入str[i]对应的字符
            int res=s(str,i+1,sb1);
            if (i+1<str.length){
                StringBuilder sb2=new StringBuilder();
                sb2.append(sb.toString());
                sb2.append(getAppendChar(str[i],str[i+1]));
                res+=s(str,i+2,sb2);
            }
            return res;
        }
        if (str[i]=='2'){
            StringBuilder sb1=new StringBuilder();
            sb1.append(sb.toString());
            sb1.append(getChar(str[i]));//加入str[i]对应的字符
            int res=s(str,i+1,sb1);
            if (i+1<str.length&&str[i+1]>='0'&&str[i+1]<='6'){
                StringBuilder sb2=new StringBuilder();
                sb2.append(sb.toString());
                sb2.append(getAppendChar(str[i],str[i+1]));//加入str[str[i]+str[i]]对应的字符
                res+=s(str,i+2,sb2);
            }
            return res;
        }
        StringBuilder sb1=new StringBuilder();
        sb1.append(sb.toString());
        sb1.append(getChar(str[i]));//加入str[i]对应的字符
        return s(str,i+1,sb1);
    }

    private static char getAppendChar(char c1, char c2) {
        int i = Character.getNumericValue(c1) * 10 + Character.getNumericValue(c2);
        return (char) ('A'+i-1);
    }

    public static char getChar(char c){
        int num = Character.getNumericValue(c);
        return (char) ('A'+num-1);
    }

    public static void main(String[] args) {
        function("21112331");
    }
}

```

### 袋子装物品

```java
package violentRecursion;
/*
* weights[i]和values[i]分别给代表i号物品的重量和价值，bag表示
* 一个载重bag的袋子，所装物品的重量不能超过这个重量
* */
public class Knapsack {

    public static int process(int[] weights,int[] values,int i,int bag,int usedWeight){
        if (usedWeight>bag){
            return -values[i-1];
        }
        if (i==weights.length){
            return 0;
        }
        //可以装
        return Math.max(values[i]+process(weights,values,i+1,bag,usedWeight+weights[i]),
                process(weights,values,i+1,bag,usedWeight));
    }

    public static int process2(int[] weights,int[] values,int i,int bag,
                               int alreadyWeight,int alreadyValue){
        if (alreadyWeight>bag){
            return 0;
        }
        if (i==weights.length){
            return alreadyValue;
        }
        //可以装
        return Math.max(
                process2(weights,values,i+1,bag,alreadyWeight+weights[i],alreadyValue+values[i]),
                process2(weights,values,i+1,bag,alreadyWeight,alreadyValue)
        );
    }

    public static void main(String[] args) {
        int[] weights={12,13,1,24,56,23};
        int[] values={12,13,15,16,18,120};
        System.out.println(process(weights, values, 0, 130,0));
        System.out.println(process2(weights,values,0,130,0,0));
    }
}

```











## 单链表

* 非常经典的题目！！！
* 给定两个有环也有可能无环的单链表，头节点head1和head2，请实现一个函数，如果两个链表相交，请返回第一个相交的节点，如果不相交，返回null
* 要求：如果两个链表长度和为N，时间复杂度请达到0(N),额外的空间复杂度请达

```java
package Tips;
/*
* 非常经典的题目！！！
* 给定两个有环也有可能无环的单链表，头节点head1和head2，请实现一个函数，
* 如果两个链表相交，请返回第一个相交的节点，如果不相交，返回null
* 要求：如果两个链表长度和为N，时间复杂度请达到0(N),额外的空间复杂度请达到O(1)
* */
public class FindFirstIntersectNode {
    public static class Node {
        Integer value;
        Node next;

        public Node() {
        }

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
    /*
    * 找到两个链表的第一个相交节点
    * */
    public static Node findFirstIntersectNode(Node head1,Node head2){
        if (head1==null || head2==null){
            return null;
        }
        //先找到两个链表的入环节点，以此判断是否有环
        Node loop1 = getLoopNode(head1);
        Node loop2 = getLoopNode(head2);
        //第一种可能：两个都无环
        if (loop1==null && loop2==null){
            return noLoop(head1,head2);
        }
        //第二种可能：两个都有环
        if (loop1!=null && loop2!=null) {
            bothLoop(head1,loop1,head2,loop2);
        }
        //第三种可能：一个有环，一个无环，这种情况下不可能存在相交节点
        return null;
    }
    /*
    * 找到第一个入环节点，如果无环则返回null
    * */
    public static Node getLoopNode(Node head){
        //空链表或者链表节点不足3的情况不可能有环
        if (head==null||head.next==null||head.next.next==null){
            return null;
        }
        //快慢指针
        Node n1=head.next;
        Node n2=head.next.next;
        //判断快慢指针能不能相遇，如果相遇则证明存在环
        while (n1!=n2){
            if (n2.next==null||n2.next.next==null){
                return null;
            }
            n1=n1.next;
            n2=n2.next.next;
        }
        //相遇后，快指针返回到头节点位置，两个指针同时移动，步长均为1，再次相遇的地方就是第一个入环节点
        n2=head;
        while (n1!=n2){
            n1=n1.next;
            n2=n2.next;
        }
        return n1;
    }
    /*
    * 如果两个链表都无环，返回第一个相交节点，如果不相交则返回null
    * */
    public static Node noLoop(Node head1,Node head2){
        if (head1==null || head2==null){
            return null;
        }
        Node n1 =head1;
        int n =0;
        while (n1.next !=null){
            n1 = n1.next;
            n++;
        }
        Node n2 =head2;
        while (n2.next !=null){
            n2 = n2.next;
            n--;
        }
        if (n1!=n2){
            return null;
        }
        //规定长的为n1
        n1=n>0?head1:head2;
        n2=n1==head1?head2:head1;
        n=Math.abs(n);
        while (n!=0){
            n1=n1.next;
            n--;
        }
        while (n1!=n2){
            n1=n1.next;
            n2=n2.next;
        }
        return n1;
    }
    /*
    * 两个有环链表返回第一个相交节点，如果不相交返回null
    * */
    public static Node bothLoop(Node head1,Node loop1,Node head2,Node loop2){
        //两个都有环，那么可能有相同的环，有相同的环时，入环节点可能相同也可能不相同，分两种情况讨论
        //具有两个不同环时不可能相交
        Node cur1=null;
        Node cur2=null;
        if (loop1==loop2){
            //第一种情况，两个链表拥有相同的入环节点，那么第一个相交的节点在入环节点的前面部分
            //以入环节点为终止节点，按照两个无环链表的思路寻找第一个相交节点
            cur1=head1;
            cur2=head2;
            int n =0;
            while (cur1!=loop1){
                cur1=cur1.next;
                n++;
            }
            while (cur2!=loop2){
                cur2=cur2.next;
                n--;
            }
            cur1=n>0?head1:head2;
            cur2=cur1==head1?head2:head1;
            n=Math.abs(n);
            while (n!=0){
                cur1=cur1.next;
                n--;
            }
            while (cur1!=cur2){
                cur1=cur1.next;
                cur2=cur2.next;
            }
            return cur1;
        }else{
            //两个链表有不同的入环节点
            cur1=loop1.next;
            while (loop1!=cur1){
                if (cur1==loop2){
                    //两个链表有不同的入环节点，但是具有相同的环
                    return loop1;
                }
                cur1=cur1.next;
            }
            //两个链表有不同的环，入环节点肯定也不相同
            return null;
        }
    }


    public static void main(String[] args) {
        Node end = new Node(0, null);
        Node n1 = new Node(1, end);
        Node n2 = new Node(2, n1);
        Node n3 = new Node(3, n2);
        Node n4 = new Node(4, n3);
        Node n5 = new Node(5, n4);
        Node n6 = new Node(6, n5);
        Node n61 = new Node(61, n6);
        Node n62 = new Node(62, n6);
        Node head1 = new Node(71, n61);
        Node n72 = new Node(72, n62);
        Node n82 = new Node(82, n72);
        Node n92= new Node(92, n82);
        Node head2= new Node(102, n92);
        end.next=n6;
        Node node = bothLoop(head1,n6, head2,n6);
        System.out.println(node.value);
    }
}

```

## 二叉树

```java
package dataStructure;
import java.util.*;
import java.util.Queue;
import java.util.Stack;

/*
 * 二叉树
 * 三种遍历方式+层序遍历
 * 求最大宽度
 * */
public class BinaryTree {
    /*
     * 二叉树节点
     * */
    private static class Node {
        Integer value;
        Node left;
        Node right;

        public Node(Integer value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    /*
     * 递归实现前序遍历
     * */
    public static void preOrder(Node head) {
        if (head == null) {
            return;
        }
        System.out.print(head.value + " ");
        preOrder(head.left);
        preOrder(head.right);
    }

    /*
     * 非递归实现前序遍历
     * */
    public static void preOrderUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            stack.push(head);
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.value + " ");
                if (head.right != null) {
                    stack.push(head.right);
                }
                if (head.left != null) {
                    stack.push(head.left);
                }
            }
        }
    }

    /*
     * 递归实现中序遍历
     * */
    public static void inOrder(Node head) {
        if (head == null) {
            return;
        }
        inOrder(head.left);
        System.out.print(head.value + " ");
        inOrder(head.right);
    }

    /*
     * 非递归实现中序遍历
     * */
    public static void inOrderUnRecur(Node head) {
        /*if (head != null) {
            Stack<Node> stack = new Stack<>();
            while (head != null) {
                stack.push(head);
                head = head.left;
            }
            while (!stack.isEmpty()) {
                head = stack.pop();
                System.out.print(head.value + " ");
                head = head.right;
                while (head != null) {
                    stack.push(head);
                    head = head.left;
                }
            }
        }*/
        if (head != null) {
            Stack<Node> stack = new Stack<>();
           while (!stack.isEmpty() || head!=null){//栈非空或者还有需要压入栈的节点时需要走循环
               if (head!=null){
                   stack.push(head);
                   head=head.left;
               }else{
                   head = stack.pop();
                   System.out.print(head.value+" ");
                   head=head.right;
               }
           }
        }
    }

    /*
     * 递归实现后序遍历
     * */
    public static void posOrder(Node head) {
        if (head == null) {
            return;
        }
        posOrder(head.left);
        posOrder(head.right);
        System.out.print(head.value + " ");
    }

    /*
     * 非递归实现后序遍历
     * */
    public static void posOrderUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            stack.push(head);
            Stack<Node> temp = new Stack<>();
            while (!stack.isEmpty()) {
                head = stack.pop();
                temp.push(head);
                if (head.left != null) {
                    stack.push(head.left);
                }
                if (head.right != null) {
                    stack.push(head.right);
                }
            }
            while (!temp.isEmpty()) {
                System.out.print(temp.pop().value + " ");
            }
        }
    }

    /*
    * 宽度优先遍历,也就是层序遍历
    * */
    public static void wOrder(Node head){
        int max=Integer.MIN_VALUE;
        if (head!=null){
            Queue<Node> queue=new LinkedList<>();
            HashMap<Node,Integer> map=new HashMap<>();
            int curLevel=1;
            int curLevelNodes =0;
            map.put(head,1);
            queue.add(head);
            while (!queue.isEmpty()){
                Node cur=queue.poll();
                int curNodeLevel=map.get(cur);
                if (curNodeLevel==curLevel){
                    curLevelNodes++;
                }else{
                    curLevel++;
                    max=Math.max(max, curLevelNodes);
                    curLevelNodes =1;
                }
                System.out.print(cur.value+" ");
                if (cur.left!=null){
                    map.put(cur.left,curNodeLevel+1);
                    queue.add(cur.left);
                }
                if (cur.right!=null){
                    map.put(cur.right,curNodeLevel+1);
                    queue.add(cur.right);
                }
            }
            max=Math.max(max,curLevelNodes);//最后要再比较一次，否则不会考虑最后一层的宽度
        }
//        System.out.println(max);
    }
    public static void main(String[] args) {
        Node n4 = new Node(4, null, null);
        Node n5 = new Node(5, null, null);
        Node n6 = new Node(6, null, null);
        Node n7 = new Node(7, null, null);
        Node n2 = new Node(2, n4, n5);
        Node n3 = new Node(3, n6, n7);
        Node head = new Node(1, n2, n3);
        preOrder(head);// 1 2 4 5 3 6 7
        System.out.println("递归实现前序遍历");
        preOrderUnRecur(head);// 1 2 4 5 3 6 7
        System.out.println("非递归实现前序遍历");
        inOrder(head);// 4 2 5 1 6 3 7
        System.out.println("递归实现中序遍历");
        inOrderUnRecur(head);// 4 2 5 1 6 3 7
        System.out.println("非递归实现中序遍历");
        posOrder(head);// 4 5 2 6 7 3 1
        System.out.println("递归实现后序遍历");
        posOrderUnRecur(head);// 4 5 2 6 7 3 1
        System.out.println("非递归实现后序遍历");
        wOrder(head);// 1 2 3 4 5 6 7
        System.out.println("层序遍历");

    }
}

```

#### 搜索树

* 搜索树：左子树比自己小，右子树比自己大，每个子树都

```java
package Tips;

import java.util.*;

/*
 * 判断是不是搜索树
 * 搜索树：左子树比自己小，右子树比自己大，每个子树都满足该特性
 * */
public class BST {

/*
     * 采用morris实现二叉树中序遍历
     * 来判断是不是搜索二叉树
     * */
    public static boolean morrisInIsBST(TreeNode head){
        if (head ==null){
            return false;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        int preValue=Integer.MIN_VALUE;
        while (cur!=null){//过流程
            mostRight=cur.left;//找cur左子树上的最右节点，从左子树头节点开始寻找mostRight
            if (mostRight!=null){//有左子树
                while (mostRight.right!=null && mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                if (mostRight.right==null){//这是第一次来到cur
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//mostRight.right==cur
                    mostRight.right=null;//之前来过cur,接下来要移到cur.right
                }
            }
            if (cur.val<=preValue){
                return false;
            }
            preValue=cur.val;
            cur=cur.right;//cur没有左子树或者已经走完左子树
        }
        return true;
    }
    /*
     * 二叉树节点
     * */
    public static class Node {
        Integer value;
        Node left;
        Node right;

        public Node(Integer value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    /*
    * 方法一： 搞复杂了，没有那么复杂
    *  遍历 中序遍历后的队列
    * 判断是否满足搜索树的条件
    * */
    public static boolean isBST(Node head) {
        Queue<Integer> queue = process1(head);
        if (queue!=null){
            int s = queue.poll();
            while (!queue.isEmpty()) {
                int m = queue.poll();
                if (s >= m) {
                    return false;
                }
                s=m;
            }
        }
        return true;
    }
    /*
    * 递归实现中序遍历1
    * 将链表中序遍历放到队列中返回
    * */
    private static Queue<Integer> process1(Node head) {
        if (head == null) {
            return null;
        }
        Queue<Integer> left = process1(head.left);
        if (left != null) {
            left.add(head.value);
            Queue<Integer> right = process1(head.right);
            while (right != null && !right.isEmpty()) {
                left.add(right.poll());
            }
            return left;
        } else {
            Queue<Integer> cur = new LinkedList<>();
            cur.add(head.value);
            Queue<Integer> right = process1(head.right);
            while (right != null && !right.isEmpty()) {
                left.add(right.poll());
            }
            return cur;
        }
    }

    /*
     * 方法二：推荐！
     * 递归实现中序遍历2
     * */
    public static Integer preValue =Integer.MIN_VALUE;
    private static boolean isBST2(Node head) {
        if (head == null) {
            return true;
        }
        boolean left= isBST2(head.left);
        if (!left){
            return false;
        }
        if (head.value<= preValue){
            return false;
        }else{
            preValue =head.value;
        }
        return isBST2(head.right);
    }

    /*
    * 方法三：最简单
    * 中序遍历放集合
    * */
    public static boolean isBST3(Node head){
        if (head==null){
            return false;
        }
        List<Node> list=new ArrayList<>();
        process3(head,list);
        Node preNode = list.remove(0);
        for (Node cur : list) {
            if (preNode.value>=cur.value){
                return false;
            }
            preNode=cur;
        }
        return true;
    }
    private static void process3(Node head,List<Node> list){
        if (head == null) {
            return;
        }
       process3(head.left,list);
        list.add(head);
        process3(head.right,list);
    }

    /*
     * 递归判断是不是搜索树
     * */
    private static class Result{
        int max;
        int min;
        boolean isBST;

        public Result(int max, int min, boolean isBST) {
            this.max = max;
            this.min = min;
            this.isBST = isBST;
        }
    }
    public static Result isBstRecur(Node head){
        if (head==null){
            return new Result(Integer.MIN_VALUE,Integer.MAX_VALUE,true);
        }
        Result leftResul = isBstRecur(head.left);
        Result rightResult = isBstRecur(head.right);
        int max=Math.max(head.value,Math.max(leftResul.max, rightResult.max));
        int min=Math.min(head.value,Math.min(leftResul.min,rightResult.min));
        boolean isBST= leftResul.isBST && rightResult.isBST && (head.value>leftResul.max)&&(head.value< rightResult.min);
        return new Result(max,min,isBST);
    }

    /*
     * 利用非递归实现中序遍历
     * 来判断是不是搜索树
     * */
    public static boolean isBstUnRecur(Node head) {
        if (head != null) {
            Stack<Node> stack = new Stack<>();
            Integer preValue =Integer.MIN_VALUE;
            while (!stack.isEmpty() || head!=null){//栈非空或者还有需要压入栈的节点时需要走循环
                if (head!=null){
                    stack.push(head);
                    head=head.left;
                }else{
                    head = stack.pop();
                    if (head.value<= preValue){
                        return false;
                    }
                    preValue =head.value;
//                    System.out.print(head.value+" ");//中序遍历
                    head=head.right;
                }
            }
        }
        return true;
    }
    public static void main(String[] args) {
        Node n8 = new Node(1, null, null);
        Node n4 = new Node(2, n8, null);
        Node n5 = new Node(4, null, null);
        Node n6 = new Node(61, null, null);
        Node n7 = new Node(8, null, null);
        Node n2 = new Node(3, n4, n5);
        Node n3 = new Node(7, n6, n7);
        Node head = new Node(5, n2, n3);
        System.out.println(isBST(head));
        System.out.println(isBST2(head));
        System.out.println(isBST3(head));
        System.out.println(isBstUnRecur(head));
        System.out.println(isBstRecur(head).isBST);
    }
}

```



#### 完全二叉树

```java
package Tips;
import dataStructure.TreeNode;

import javax.swing.tree.DefaultMutableTreeNode;
import java.util.LinkedList;
import java.util.Queue;

/*
* 判断一个二叉树是不是完全二叉树
* */
public class CompleteBinaryTree {


    public static boolean isW(TreeNode head){
        if (head==null){
            return false;
        }
        Queue<TreeNode> queue=new LinkedList<>();
        /*
        * 标记：是否遇到过第一个左右子不全的节点,第一次遇到时标记为true，
        * 后面遇到叶节点也会标记为true但是不影响判断,因为不改变flag的值
        * */
        boolean flag=false;
        queue.add(head);
        while (!queue.isEmpty()){
            head= queue.poll();
            /*
            * 判断是否满足完全二叉树的特性
            * 1. 存在右子树却没有左子树不是二叉树
            * 2. 如果是第一个左右子不全，则后续皆是叶节点-->已经遇到过第一个左右子不全的节点，
            *    但是还遇到不是叶节点的节点flag &&(head.right!=null || head.left!=null）
            * */
            if ((head.right!=null && head.left==null)||(flag &&(head.right!=null || head.left!=null))){
                return false;
            }
            if (head.left == null || head.right == null){
                flag=true;
            }
            if (head.left!=null){
                queue.add(head.left);
            }
            if (head.right!=null){
                queue.add(head.right);
            }
        }
        return true;
    }

    public static void main(String[] args) {
        TreeNode n8= new TreeNode(8, null, null);
        TreeNode n4 = new TreeNode(4, n8, null);
        TreeNode n5 = new TreeNode(5, null, null);
        TreeNode n6 = new TreeNode(6, null, null);
        TreeNode n7 = new TreeNode(7, null, null);
        TreeNode n2 = new TreeNode(2, n4, n5);
        TreeNode n3 = new TreeNode(3, n6, n7);
        TreeNode head = new TreeNode(1, n2, n3);
        System.out.println(isW(head));
    }
}

```

```java
// 树节点

public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return String.valueOf(this.val);
    }
}


```

#### 平衡二叉树

```java
package Tips;
import dataStructure.TreeNode;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

/*
* 平衡二叉树
* 左右子树的高度差不会超过1(高度差小于2)
* */
public class BalancedBinaryTree {
    private static class Result{
        boolean isBalanced;
        int height;

        public Result(boolean isBalanced, int height) {
            this.isBalanced = isBalanced;
            this.height = height;
        }
    }
    public static boolean isBalancedBinaryTree(TreeNode head){
        if (head==null){
            return false;
        }
        return process(head).isBalanced;
    }
    private static Result process(TreeNode head){
        if (head==null){
            return new Result(true,0);
        }
        Result leftResult = process(head.left);
        Result rightResult = process(head.right);
        int height=Math.max(leftResult.height,rightResult.height)+1;//高度就是左右子节点中高一点的节点的高度加一！！！
        boolean isBalanced=leftResult.isBalanced&&rightResult.isBalanced&&(Math.abs(leftResult.height-rightResult.height)<2);
        return new Result(isBalanced,height);
 }
   }
```

#### 满二叉树

```java
package Tips;


import dataStructure.TreeNode;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

/*
* 判断是否为满二叉树
* 最大的深度L和节点数N
* 满足：N=2^L-1
* */
public class FullBinaryTree {
    /*
    * 非递归方式判断
    * 自己写的应该没有问题的
    * */
    public static boolean isFullBinaryTreeUnRecur(TreeNode head){
        if (head==null){
            return false;
        }
        Queue<TreeNode> queue=new LinkedList<>();
        HashMap<TreeNode,Integer> levelMap=new HashMap<>();
        int L =1;
        int N =0;
        queue.add(head);
        levelMap.put(head,1);
        while (!queue.isEmpty()){
            TreeNode curNode = queue.poll();
            Integer curNodeLevel = levelMap.get(curNode);
            L=curNodeLevel;
            N++;
            if (curNode.left!=null){
                levelMap.put(curNode.left,curNodeLevel+1);
                queue.add(curNode.left);
            }
            if (curNode.right!=null){
                levelMap.put(curNode.right,curNodeLevel+1);
                queue.add(curNode.right);
            }
        }

        return N==(1<<L) -1;
    }

    private static class Result{
        int height;
        int nodes;

        public Result(int level, int nodes) {
            this.height = level;
            this.nodes = nodes;
        }
    }
    public static boolean isFullBinaryTreeRecur(TreeNode head){
        if (head==null){
            return false;
        }
        Result result = isFullBinaryTree(head);
//        return result.nodes==(Math.pow(2,result.height) -1);
        return result.nodes==(1<< result.height) -1;//位运算这里可能有问题。。是这么写的吧，是是

    }
    public static Result isFullBinaryTree(TreeNode head){
        if (head==null){
            return new Result(0,0);
        }
        Result leftResult = isFullBinaryTree(head.left);
        Result rightResult = isFullBinaryTree(head.right);
        int level=Math.max(leftResult.height,rightResult.height)+1;
        int nodes=leftResult.nodes+ rightResult.nodes+1;
        return new Result(level,nodes);
    }

    public static void main(String[] args) {
        TreeNode n9=new TreeNode(9,null,null);
        TreeNode n8= new TreeNode(8, n9, null);
        TreeNode n4 = new TreeNode(4, null, n8);
        TreeNode n5 = new TreeNode(5, null, null);
        TreeNode n6 = new TreeNode(6, null, null);
        TreeNode n7 = new TreeNode(7, null, null);
        TreeNode n2 = new TreeNode(2, n4, n5);
        TreeNode n3 = new TreeNode(3, n6, n7);
        TreeNode head = new TreeNode(1, n2, n3);
        System.out.println(isFullBinaryTreeRecur(head));
        System.out.println(isFullBinaryTreeUnRecur(head));
    }


}

```

#### AVL树（左树和右树大小不超过1）

1. 当插入或删除一个节点时，可能会让整棵AVL树不平衡。此时，只需要把最小不平衡子树调整即可恢复整体的平衡性。

2. 树的LL,RR,LR,RL调整。

3. 插入和删除时的调整细节。
   
   
   
   

#### SB树

1. 每棵树的大小，不小于其兄弟的子树大小。

2. 即没棵叔叔树的大小，不小于其任何侄子树的大小
   
   

#### 最低公共祖先节点

```java
package Tips;

import dataStructure.TreeNode;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/*
* 给定一棵树上的两个树节点
* 找出最低的公共祖先节点
* */
public class FindFirstFatherNode {
    /*
     * 最佳方案！！！
     * */
    public static TreeNode bestSolution(TreeNode head,TreeNode n1,TreeNode n2){
        if (head==null || head==n1 || head==n2){
            return head;
        }
        TreeNode left = bestSolution(head.left, n1, n2);
        TreeNode right = bestSolution(head.right, n1, n2);
        //左右两棵树都有返回值，就是汇聚
        if (left!=null && right!=null){
            return head;
        }
        //不是都有返回值，返回有值的那个，也有可能都没有值
        return left!=null?left:right;
    }

    /*
    * 把一个节点到根节点经过的节点都放到一个set集合中
    * 然后让另一个节点往上窜，如果往上窜的过程中与set集合中的节点相遇
    * 那么该节点就是最低的公共祖先节点
    * */
    public static TreeNode findFFNode(TreeNode head,TreeNode n1,TreeNode n2){
        if (head==null){
            return null;
        }
        HashMap<TreeNode,TreeNode> fatherMap=new HashMap<>();
        fatherMap.put(head,head);
        getFatherNode(head,fatherMap);
        Set<TreeNode> set1=new HashSet<>();
        TreeNode cur=n1;
        while (fatherMap.get(cur)!=cur){
            set1.add(cur);
            cur=fatherMap.get(cur);
        }
        set1.add(head);
        while (fatherMap.get(n2)!=n2){
            if (set1.contains(n2)){
                return n2;
            }
            n2=fatherMap.get(n2);
        }
        return head;
    }
    /*
    * 遍历整棵树获取每个节点的父节点并放到HashMap中
    * HashMap<子节点,父节点>
    * */
    private static void getFatherNode(TreeNode head, HashMap<TreeNode,TreeNode> fatherMap){
       if (head==null){
           return;
       }
        fatherMap.put(head.left,head);
        fatherMap.put(head.right,head);
       getFatherNode(head.left,fatherMap);
       getFatherNode(head.right,fatherMap);
    }
    public static void main(String[] args) {
        TreeNode n9=new TreeNode(9,null,null);
        TreeNode n8= new TreeNode(8, n9, null);
        TreeNode n4 = new TreeNode(4, null, n8);
        TreeNode n5 = new TreeNode(5, null, null);
        TreeNode n6 = new TreeNode(6, null, null);
        TreeNode n7 = new TreeNode(7, null, null);
        TreeNode n2 = new TreeNode(2, n4, n5);
        TreeNode n3 = new TreeNode(3, n6, n7);
        TreeNode head = new TreeNode(1, n2, n3);
        System.out.println(findFFNode(head, n5, n9).val);
        System.out.println(bestSolution(head, n5, n8).val);
    }
}

```

#### 后继节点

```java
package Tips;
/*
 * 找到某一个树节点的后继节点
 * 后继节点就是中序遍历过程中的后一个节点
 * */
public class GetSuccessorNode {
    /*
    * 带有父节点的树节点
    * */
    private static class Node {
        int value;
        Node parent;
        Node left;
        Node right;

        public Node(int value, Node parent, Node left, Node right) {
            this.value = value;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }
    }
    /*
    * 找到后继节点
    * */
    public static Node getSuccessorNode(Node node) {
        if (node == null) {
            return null;
        }
        if (node.right != null) {//如果某节点存在右子树，那么后继节点就是右子树上最左侧的节点
            return mostLeftNode(node.right);
        }else{
            Node parent = node.parent;
            while (parent!=null && node!=parent.left){//如果当前节点是其父节点的左孩子，那么后继节点就是父节点，否则需要向上窜
                //窜到顶了说明该节点是整棵树上最右侧的节点，那么后继节点就是null
                node=parent;
                parent=node.parent;
            }
            return parent;
        }
    }

    /*
     * 找到某树上最左的节点
     * */
    private static Node mostLeftNode(Node node) {
        if (node == null) {
            return null;
        }
        Node leftNode = mostLeftNode(node.left);
        return leftNode != null ? leftNode : node;

    }
}

```

#### 折纸

```java
package Tips;
/*
* 将一个纸条对折N次
* 从上到下打印折痕的方向,打印结果满足下面的二叉树中序遍历打印
*               凹          二叉树特点：头凹，其余树节点左孩子为凹，右孩子为凸，折叠次数N等于树的高度
*             /    \
*           凹      凸
*          /  \    /  \
*        凹    凸  凹  凸   
* */
public class Exercise {

    /*
    * i为节点的层数
    * N为一共的层数
    * down==true 凹
    * down==false 凸
    * */
    public static void print(int N){
        p(N,1,true);
    }
    public static void p(int N,int i,boolean down){
        if (i>N){
            return;
        }
        p(N,i+1,true);
        System.out.print(down ?"凹":"凸");
        p(N,i+1,false);
    }
    public static void main(String[] args) {
        print(3);
    }
}


```
